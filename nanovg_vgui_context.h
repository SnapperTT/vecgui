// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
// nanovg_vgui_context.hh
//

#ifndef LZZ_nanovg_vgui_context_hh
#define LZZ_nanovg_vgui_context_hh
#define LZZ_INLINE inline
class NanoVg_Vgui_Context;
struct NanoVg_Vgui_PrerenderedText : public Vgui_PrerenderedTextI
{
  pcfc_prerendered_text prt;
  sttfont_formatted_text ft;
  NanoVg_Vgui_PrerenderedText ();
  virtual ~ NanoVg_Vgui_PrerenderedText ();
  void draw (VGUI_COORD const x, VGUI_COORD const y);
  void drawWithColorMod (VGUI_COORD const x, VGUI_COORD const y, VGUI_COLOR const r, VGUI_COLOR const g, VGUI_COLOR const b, VGUI_COLOR const a = VGUI_COLOR_MAX);
  VGUI_COORD getWidth () const;
  VGUI_COORD getHeight () const;
};
class NanoVg_Vgui_Context : public Vgui_ContextI
{
public:
  NVGcontext * mNanoContext;
  NanoVgCommandBuffer NVG;
  producer_consumer_font_cache * gFont;
  NVGcolor canvasColour;
  NVGpaint canvasPaint;
  bool usePaint;
  NanoVg_Vgui_Context ();
  virtual Vgui_PrerenderedTextI * genPrerenderedText (sttfont_formatted_text const & str) const;
  void renderTriangle (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2, VGUI_COORD const x3, VGUI_COORD const y3);
  void ctx_setScissor ();
  void ctx_setBgfxDrawScissor ();
  void ctx_clearBgfxDrawScissor ();
  void setColor (VGUI_COLOR const r, VGUI_COLOR const g, VGUI_COLOR const b, VGUI_COLOR const a);
  void setColorF (float const r, float const g, float const b, float const a);
  void prerender ();
  void setGradient (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2, uint8_t const r1, uint8_t const g1, uint8_t const b1, uint8_t const a1, uint8_t const r2, uint8_t const g2, uint8_t const b2, uint8_t const a2);
  void clearGradient ();
  void clear ();
  void renderQuad (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2);
  void renderQuadWH (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const width, VGUI_COORD const height);
  void renderArc (VGUI_COORD const originX, VGUI_COORD const originY, VGUI_COORD const radius, float const startAngle, float const endAngle);
  void renderRoundedQuadWH (VGUI_COORD const x, VGUI_COORD const y, VGUI_COORD const w, VGUI_COORD const h, VGUI_COORD const r);
  static uint64_t const cZero;
  static double const pefFq;
  double getTime () const;
  virtual void renderText (sttfont_formatted_text const & text, VGUI_COORD const x1, VGUI_COORD const y1);
  virtual void getTextSize (sttfont_formatted_text const & text, VGUI_COORD & widthOut, VGUI_COORD & heightOut, sttfont_lookupHint * mHint = NULL, VGUI_COORD const * const maxWidth = NULL) const;
  virtual VGUI_COORD getTextWidth (sttfont_formatted_text const & text, sttfont_lookupHint * mHint = NULL, VGUI_COORD const * const maxWidth = NULL) const;
  virtual VGUI_COORD getTextHeight (sttfont_formatted_text const & text, sttfont_lookupHint * mHint = NULL) const;
  virtual VGUI_COORD getTextLineHeight () const;
  virtual int getTextCaretPos (sttfont_formatted_text const & text, VGUI_COORD const & relativeX, VGUI_COORD const & relativeY, sttfont_lookupHint * mHint = NULL);
  void breakString (sttfont_formatted_text const & stringIn, VGUI_VECTOR <sttfont_formatted_text> & arrOut, VGUI_COORD const xs, bool const tokeniseNewLines = true, VGUI_VECTOR <vecgui::uintQuad> * breakPoints = NULL);
};
#undef LZZ_INLINE
#endif

////////////////////////////////////////////////////////////////////////

#ifdef VECGUI_IMPL
#ifndef VECGUI_IMPL_DOUBLE_GUARD_nanovg_vgui_context
#define VECGUI_IMPL_DOUBLE_GUARD_nanovg_vgui_context
// nanovg_vgui_context.cpp
//

#define LZZ_INLINE inline
NanoVg_Vgui_PrerenderedText::NanoVg_Vgui_PrerenderedText ()
  : Vgui_PrerenderedTextI ()
                                                             {
		//ctx = ((NanoVg_Vgui_Context *)Vgui_ContextI::aContext);
		}
NanoVg_Vgui_PrerenderedText::~ NanoVg_Vgui_PrerenderedText ()
                                               { prt.freeTexture(); }
void NanoVg_Vgui_PrerenderedText::draw (VGUI_COORD const x, VGUI_COORD const y)
                                                          {
		if (!prt.width) return;
		
		NanoVg_Vgui_Context* ctx = ((NanoVg_Vgui_Context *)Vgui_ContextI::aContext);
		ctx->ctx_setBgfxDrawScissor();
		//std::cout << "NanoVg_Vgui_PrerenderedText [" << x << ", " << y << ", " << prt.width << ", " << prt.height << "] " << ft.getString() << std::endl;
		ctx->NVG.pushSsfPrerendered(prt.handle, x, y);
		ctx->ctx_clearBgfxDrawScissor();
		}
void NanoVg_Vgui_PrerenderedText::drawWithColorMod (VGUI_COORD const x, VGUI_COORD const y, VGUI_COLOR const r, VGUI_COLOR const g, VGUI_COLOR const b, VGUI_COLOR const a)
                                                                                                                                                                       {
		//fc->drawText(x,y, ft);
		
		NanoVg_Vgui_Context* ctx = ((NanoVg_Vgui_Context *)Vgui_ContextI::aContext);
		ctx->ctx_setBgfxDrawScissor();
		ctx->NVG.pushSsfPrerenderedWColorMod(prt.handle, x, y, r, g, b, a);
		ctx->ctx_clearBgfxDrawScissor();
		}
VGUI_COORD NanoVg_Vgui_PrerenderedText::getWidth () const
                                    { return prt.width; }
VGUI_COORD NanoVg_Vgui_PrerenderedText::getHeight () const
                                     { return prt.height; }
NanoVg_Vgui_Context::NanoVg_Vgui_Context ()
  : Vgui_ContextI ()
                                                {
		mNanoContext = NULL;
		gFont = NULL;
		usePaint = false;
		}
Vgui_PrerenderedTextI * NanoVg_Vgui_Context::genPrerenderedText (sttfont_formatted_text const & str) const
                                                                                                      {
		if (!gFont) return NULL;
		NanoVg_Vgui_PrerenderedText * r = VGUI_NEW(NanoVg_Vgui_PrerenderedText);
		r->ft = str;
		gFont->renderTextToObject(&(r->prt), str);
		return r;
		}
void NanoVg_Vgui_Context::renderTriangle (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2, VGUI_COORD const x3, VGUI_COORD const y3)
                                                                                                                                                           {
		NVG.nvgBeginPath();
		NVG.nvgMoveTo(x1, y1);
		NVG.nvgLineTo(x2, y2);
		NVG.nvgLineTo(x3, y3);
		if (usePaint)
			NVG.nvgFillPaint(canvasPaint);
		else
			NVG.nvgFillColor(canvasColour);
		NVG.nvgFill();
		//NVG.nvgClosePath();
		}
void NanoVg_Vgui_Context::ctx_setScissor ()
                              {
		if (activeScissor.isNull()) {
			NVG.nvgResetScissor();
			return;
			}
		NVG.nvgScissor(activeScissor.x, activeScissor.y, activeScissor.w, activeScissor.h);
		}
void NanoVg_Vgui_Context::ctx_setBgfxDrawScissor ()
                                      {
		if (activeScissor.isNull()) {
			return;
			}
		//std::cout << "bgfxSetViewScissor" << activeScissor.x << ", " << activeScissor.y << ", " <<  activeScissor.w << ", " <<  activeScissor.h<< std::endl;
		NVG.ssfBgfxSetScissor(activeScissor.x, activeScissor.y, activeScissor.w, activeScissor.h);
		//bgfx::setViewScissor(gFont->mViewId, activeScissor.x, activeScissor.y, activeScissor.w, activeScissor.h);
		}
void NanoVg_Vgui_Context::ctx_clearBgfxDrawScissor ()
                                        {
		if (activeScissor.isNull()) {
			return;
			}
		NVG.ssfBgfxClearScissor();
		}
void NanoVg_Vgui_Context::setColor (VGUI_COLOR const r, VGUI_COLOR const g, VGUI_COLOR const b, VGUI_COLOR const a)
                                                                                                       {
		canvasColour = nvgRGBA(r,g,b,a);
		}
void NanoVg_Vgui_Context::setColorF (float const r, float const g, float const b, float const a)
                                                                                    {
		canvasColour = nvgRGBAf(r,g,b,a);
		}
void NanoVg_Vgui_Context::prerender ()
                         {
		if (!mCanvas) return;
		mCanvas->prerender();
		}
void NanoVg_Vgui_Context::setGradient (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2, uint8_t const r1, uint8_t const g1, uint8_t const b1, uint8_t const a1, uint8_t const r2, uint8_t const g2, uint8_t const b2, uint8_t const a2)
                                                                                                                                                                                                                                                             {
		canvasPaint = nvgLinearGradient(mNanoContext, x1, y1, x2, y2, nvgRGBA(r1, g1, b1, a1), nvgRGBA(r2, g2, b2, a2));
		usePaint = true;
		}
void NanoVg_Vgui_Context::clearGradient ()
                             {
		usePaint = false;
		}
void NanoVg_Vgui_Context::clear ()
                      {
		//SDL_RenderSetClipRect(mRenderer, NULL);
		setColor(VGUI_COLOR_MAX,VGUI_COLOR_MAX,VGUI_COLOR_MAX,VGUI_COLOR_MAX);
		#warning how do i do this?
		//SDL_RenderClear(mRenderer);
		}
void NanoVg_Vgui_Context::renderQuad (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2)
                                                                                                             {
		VGUI_COORD px1 = VGUI_MIN(x1, x2);
		VGUI_COORD px2 = VGUI_MAX(x1, x2);
		VGUI_COORD py1 = VGUI_MIN(y1, y2);
		VGUI_COORD py2 = VGUI_MAX(y1, y2);
		renderQuadWH(px1, py1, px2 - px1, py2 - py1);
		}
void NanoVg_Vgui_Context::renderQuadWH (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const width, VGUI_COORD const height)
                                                                                                                      {
		VGUI_COORD px1 = scalef * x1;
		VGUI_COORD py1 = scalef * y1;
		VGUI_COORD w = scalef * width;
		VGUI_COORD h = scalef * height;
		
		NVG.nvgBeginPath();
		NVG.nvgRect (px1, py1, w, h);
		if (usePaint)
			NVG.nvgFillPaint(canvasPaint);
		else
			NVG.nvgFillColor(canvasColour);
		NVG.nvgFill();
		}
void NanoVg_Vgui_Context::renderArc (VGUI_COORD const originX, VGUI_COORD const originY, VGUI_COORD const radius, float const startAngle, float const endAngle)
                                                                                                                                                   {
		NVG.nvgBeginPath();
		NVG.nvgMoveTo(originX, originY);
		NVG.nvgArc (originX, originY, radius, startAngle, endAngle, 2); // NVGWinding::NVG_CCW == 1
		if (usePaint)
			NVG.nvgFillPaint(canvasPaint);
		else
			NVG.nvgFillColor(canvasColour);
		NVG.nvgFill();
		}
void NanoVg_Vgui_Context::renderRoundedQuadWH (VGUI_COORD const x, VGUI_COORD const y, VGUI_COORD const w, VGUI_COORD const h, VGUI_COORD const r)
                                                                                                                                      {
		NVG.nvgBeginPath();
		NVG.nvgRoundedRect (x, y, w, h, r);
		if (usePaint)
			NVG.nvgFillPaint(canvasPaint);
		else
			NVG.nvgFillColor(canvasColour);
		NVG.nvgFill();
		}
uint64_t const NanoVg_Vgui_Context::cZero = SDL_GetPerformanceCounter();
double const NanoVg_Vgui_Context::pefFq = SDL_GetPerformanceFrequency();
double NanoVg_Vgui_Context::getTime () const
                               {
		return (SDL_GetPerformanceCounter() - cZero)/pefFq;
		}
void NanoVg_Vgui_Context::renderText (sttfont_formatted_text const & text, VGUI_COORD const x1, VGUI_COORD const y1)
                                                                                                                {
		if (!gFont) return;
		//gFont->drawText(scalef*x1, scalef*y1, text);
		pcfc_handle h = gFont->pushText(scalef*x1, scalef*y1, text);
		
		ctx_setBgfxDrawScissor();		
		NVG.pushSsfText(h);
		ctx_clearBgfxDrawScissor();
		}
void NanoVg_Vgui_Context::getTextSize (sttfont_formatted_text const & text, VGUI_COORD & widthOut, VGUI_COORD & heightOut, sttfont_lookupHint * mHint, VGUI_COORD const * const maxWidth) const
                                                                                                                                                                                                         {
		if (!gFont) return;
		int w, h;
		int maxWidthi = maxWidth ? *maxWidth : 0;
		gFont->getTextSize(w, h, text, mHint, maxWidthi ? &maxWidthi : NULL);
		widthOut = w/scalef;
		heightOut = h/scalef;
		}
VGUI_COORD NanoVg_Vgui_Context::getTextWidth (sttfont_formatted_text const & text, sttfont_lookupHint * mHint, VGUI_COORD const * const maxWidth) const
                                                                                                                                                                 {
		if (!gFont) return 0;		
		int widthOut, heightOut;
		int maxWidthi = maxWidth ? *maxWidth : 0;
		gFont->getTextSize(widthOut, heightOut, text, mHint, maxWidthi ? &maxWidthi : NULL);
		return widthOut / scalef;
		}
VGUI_COORD NanoVg_Vgui_Context::getTextHeight (sttfont_formatted_text const & text, sttfont_lookupHint * mHint) const
                                                                                                                        {
		if (!gFont) return 0;
		return gFont->getTextHeight(text) / scalef;
		}
VGUI_COORD NanoVg_Vgui_Context::getTextLineHeight () const
                                                     {
		if (!gFont) return Vgui_ContextI::getTextLineHeight();
		return gFont->getScaledRowSize() / scalef;
		}
int NanoVg_Vgui_Context::getTextCaretPos (sttfont_formatted_text const & text, VGUI_COORD const & relativeX, VGUI_COORD const & relativeY, sttfont_lookupHint * mHint)
                                                                                                                                                                         {
		if (!gFont) return -1;
		return gFont->getCaretPos(text, relativeX * scalef, relativeY * scalef, mHint);
		}
void NanoVg_Vgui_Context::breakString (sttfont_formatted_text const & stringIn, VGUI_VECTOR <sttfont_formatted_text> & arrOut, VGUI_COORD const xs, bool const tokeniseNewLines, VGUI_VECTOR <vecgui::uintQuad> * breakPoints)
                                                                                                        {
		vecgui::breakString_worker(gFont, stringIn, arrOut, xs, tokeniseNewLines, breakPoints);	
		}
#undef LZZ_INLINE
#endif //VECGUI_IMPL_DOUBLE_GUARD_nanovg_vgui_context
#endif //VECGUI_IMPL_IMPL
