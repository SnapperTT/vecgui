// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
// vgui.hh
//

#ifndef LZZ_vgui_hh
#define LZZ_vgui_hh
#include "vgui_constants.hpp"

//#define VGUI_USE_INT
#define VGUI_USE_DOUBLE

#ifdef VGUI_DO_DELTA_DRAWING
	#undef VGUI_DO_DELTA_DRAWING
	#define VGUI_DO_DELTA_DRAWING true
#else
	#define VGUI_DO_DELTA_DRAWING false
#endif

#ifdef VGUI_USE_INT

	#ifndef VGUI_COORD
		#define VGUI_COORD int
	#endif
	#ifndef VGUI_ABS
		#define VGUI_ABS abs
	#endif
	#ifndef VGUI_FUZZY_ZERO
		#define VGUI_FUZZY_ZERO(X) (X == 0)
	#endif
	#ifndef VGUI_COORD_MIN_VALUE
		#define VGUI_COORD_MIN_VALUE -0x0fffffff
	#endif
	#ifndef VGUI_COORD_MAX_VALUE
		#define VGUI_COORD_MAX_VALUE 0x0fffffff
	#endif
	
#elif defined(VGUI_USE_DOUBLE)
	#ifndef VGUI_COORD
		#define VGUI_COORD double
	#endif
	#ifndef VGUI_ABS
		#define VGUI_ABS fabs
	#endif
	#ifndef VGUI_FUZZY_ZERO
		#define VGUI_FUZZY_ZERO(X) (VGUI_ABS(X) < 0.001)
	#endif
	#ifndef VGUI_COORD_MIN_VALUE
		#define VGUI_COORD_MIN_VALUE double(int(-0x0fffffff))
	#endif
	#ifndef VGUI_COORD_MAX_VALUE
		#define VGUI_COORD_MAX_VALUE double(int(0x0fffffff))
	#endif
#endif


#ifndef VGUI_COLOR
	#define VGUI_COLOR uint8_t
#endif
#ifndef VGUI_COLOR_MAX
	#define VGUI_COLOR_MAX 255
#endif

#ifndef VGUI_STRING
	#define VGUI_STRING std::string
	#include <string>
#endif

#ifndef VGUI_TAG_TYPE
	#define VGUI_TAG_TYPE VGUI_STRING
#endif

#ifndef VGUI_VECTOR
	#define VGUI_VECTOR std::vector
	#include <vector>
#endif

#ifndef VGUI_MIN
	#define VGUI_MIN(X,Y) (X < Y ? X : Y)
#endif
#ifndef VGUI_MAX
	#define VGUI_MAX(X,Y) (X > Y ? X : Y)
#endif
#ifndef VGUI_CLAMP
	#define VGUI_CLAMP(X,L,H) VGUI_MIN(VGUI_MAX(X,L), H)
#endif



#ifndef VGUI_NEW
	#define VGUI_NEW(X) new (X)
#endif
#ifndef VGUI_DEL
	#define VGUI_DEL(X) delete (X)
#endif

class Vgui_Widget;
class Vgui_SkinI;
class Vgui_Style;

void Vgui_Abort(const char * ext);

template <typename T, int maxSz>
struct Vgui_MaxSizeArray {
	T array[maxSz];
	int sz;
	
	Vgui_MaxSizeArray() : sz(0) {}
	inline void push_back(T&&v) {
		if (sz >= maxSz) { Vgui_Abort("buffer overflow"); }
		array[sz] = std::move(v); sz++;
		}
	inline void push_back(const T&v) {
		if (sz >= maxSz) { Vgui_Abort("buffer overflow"); }
		array[sz] = std::move(v); sz++;
		}
	inline int size() const { return sz; }
	inline T& operator[](const int idx) { return array[idx]; }
	inline const T& operator[](const int idx) const { return array[idx]; }
	inline void clear()  { sz = 0; }
	};
	


void Vgui_Cleanup();
#define LZZ_INLINE inline
#undef LZZ_INLINE
#endif

////////////////////////////////////////////////////////////////////////

#ifdef VECGUI_IMPL
#ifndef VECGUI_IMPL_DOUBLE_GUARD_vgui
#define VECGUI_IMPL_DOUBLE_GUARD_vgui
// vgui.cpp
//

//#include "vgui_context.cpp"
//#include "vgui_widget.cpp"
//#include "vgui_skin.cpp"
//#include "vgui_elements.cpp"
//#include "vgui_multilinetext.cpp"
//#include "vgui_stringfunctions.cpp"

//#include "sdl_vgui_context.cpp"

void Vgui_Abort(const char * ext) {
	abort();
	}
void Vgui_Cleanup() {
	Vgui_SkinI::defaultSkin.freeDefaultStyles();
	}
#define LZZ_INLINE inline
#undef LZZ_INLINE
#endif //VECGUI_IMPL_DOUBLE_GUARD_vgui
#endif //VECGUI_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
// vgui_skin.hh
//

#ifndef LZZ_vgui_skin_hh
#define LZZ_vgui_skin_hh
#define LZZ_INLINE inline
namespace Vgui_StyleStuff
{
  struct colorTint
  {
    float r;
    float g;
    float b;
    float a;
    colorTint ();
    colorTint (float v);
    colorTint (float _r, float _g, float _b, float _a = 1.f);
  };
}
namespace Vgui_StyleStuff
{
  struct paintInfo
  {
    VGUI_COLOR r;
    VGUI_COLOR g;
    VGUI_COLOR b;
    VGUI_COLOR a;
    bool manuallySet;
    paintInfo ();
    void bind (colorTint const & ct) const;
    void setF (float v);
    void setF (float _r, float _g, float _b, float _a = 1.f);
  };
}
namespace Vgui_StyleStuff
{
  struct coord_element
  {
    Vgui_PosMode posMode;
    VGUI_COORD value;
    coord_element ();
    coord_element (Vgui_PosMode const _pm, VGUI_COORD const _v);
  };
}
namespace Vgui_StyleStuff
{
  struct coord_formula
  {
    Vgui_MaxSizeArray <coord_element, 4> mElements;
    VGUI_COORD cachedValue;
    coord_formula ();
    coord_formula & assign (Vgui_PosMode const posMode, VGUI_COORD const value);
    coord_formula & addElement (Vgui_PosMode const posMode, VGUI_COORD const value);
    coord_formula & subElement (Vgui_PosMode const posMode, VGUI_COORD const value);
    void recalcValues (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding, bool const isX);
    operator VGUI_COORD () const;
  };
}
namespace Vgui_StyleStuff
{
  struct coord_formula_bbox
  {
    coord_formula x1;
    coord_formula y1;
    coord_formula x2;
    coord_formula y2;
    void recalcValues (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding);
  };
}
namespace Vgui_StyleStuff
{
  struct primative
  {
    VGUI_VECTOR <primative*> childPrimatives;
    paintInfo paint;
    paintInfo paintActive;
    paintInfo paintHover;
    paintInfo paintHoverActive;
    primative ();
    virtual ~ primative ();
    virtual void updateCachedValue (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding);
    void updateCachedValue_children (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding);
    virtual primative * clone () const;
    void base_clone (primative * r) const;
    void bindPaint (Vgui_Widget const & vw, colorTint const & ct) const;
    virtual void draw (Vgui_Widget const & vw, colorTint const & tint) const;
    void drawChildren (Vgui_Widget const & vw, colorTint const & tint) const;
    void clear ();
    void fixPaint ();
  };
}
namespace Vgui_StyleStuff
{
  struct rectPrimative : public primative
  {
    coord_formula x1;
    coord_formula y1;
    coord_formula x2;
    coord_formula y2;
    rectPrimative ();
    ~ rectPrimative ();
    primative * clone () const;
    void updateCachedValue (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding);
    void draw (Vgui_Widget const & vw, colorTint const & tint) const;
  };
}
namespace Vgui_StyleStuff
{
  struct triPrimative : public primative
  {
    coord_formula x1;
    coord_formula y1;
    coord_formula x2;
    coord_formula y2;
    coord_formula x3;
    coord_formula y3;
    triPrimative ();
    ~ triPrimative ();
    primative * clone () const;
    void updateCachedValue (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding);
    void draw (Vgui_Widget const & vw, colorTint const & tint) const;
  };
}
class Vgui_Style
{
public:
  VGUI_VECTOR <Vgui_StyleStuff::primative*> primatives;
  VGUI_COORD elementPadding;
  VGUI_COORD barWidth;
  VGUI_COORD minHandleSize;
  double caretBlinkPeriod;
  double caretBlinkDutyCycle;
  Vgui_StyleStuff::coord_formula innerPaddingT;
  Vgui_StyleStuff::coord_formula innerPaddingB;
  Vgui_StyleStuff::coord_formula innerPaddingL;
  Vgui_StyleStuff::coord_formula innerPaddingR;
  Vgui_StyleStuff::coord_formula innerPaddingB_scrollBar;
  Vgui_StyleStuff::coord_formula innerPaddingR_scrollBar;
  Vgui_StyleStuff::coord_formula textXSizePadding;
  Vgui_StyleStuff::coord_formula textYSizePadding;
  Vgui_StyleStuff::coord_formula_bbox xScrollbarBBox;
  Vgui_StyleStuff::coord_formula_bbox yScrollbarBBox;
  Vgui_StyleStuff::coord_formula_bbox textBBox;
  Vgui_Alignment textAlignment;
  VGUI_COORD activeTextXNudge;
  VGUI_COORD activeTextYNudge;
  bool drawCaretWhenActive;
  bool isCustom;
  Vgui_Style ();
  virtual ~ Vgui_Style ();
  void clearPrimatives ();
  bool hasSamePrimatives (Vgui_Style const & other) const;
  void fixPaint ();
  Vgui_Style * clone () const;
  void clone_in_place (Vgui_Style & target, bool const fullDestroyPrimitives) const;
  void draw (Vgui_Widget & vw);
  void drawBlinkingCaretAt (sttfont_formatted_text const & text, int caretPosition, VGUI_COORD const & textStartX, VGUI_COORD const & textStartY, VGUI_COORD const & textRowSz);
  virtual void getTextStartPosTextEdit (Vgui_Widget const & vw, VGUI_COORD const & relMouseX, VGUI_COORD const & relMouseY, VGUI_COORD & posOutX, VGUI_COORD & posOutY);
  void updateCachedValues (Vgui_Widget const & vw);
  void getInnerPadding (Vgui_Widget const & vw, VGUI_COORD & _innerPaddingT, VGUI_COORD & _innerPaddingB, VGUI_COORD & _innerPaddingL, VGUI_COORD & _innerPaddingR);
  virtual void getVertScrollbarCoords (Vgui_Widget const & vw, VGUI_COORD & scrollbarX, VGUI_COORD & scrollbarY, VGUI_COORD & scrollbarWidth, VGUI_COORD & scrollbarHeight, VGUI_COORD & scrollbarHandleX, VGUI_COORD & scrollbarHandleY, VGUI_COORD & scrollbarHandleWidth, VGUI_COORD & scrollbarHandleHeight);
  virtual void getHorzScrollbarCoords (Vgui_Widget const & vw, VGUI_COORD & scrollbarX, VGUI_COORD & scrollbarY, VGUI_COORD & scrollbarWidth, VGUI_COORD & scrollbarHeight, VGUI_COORD & scrollbarHandleX, VGUI_COORD & scrollbarHandleY, VGUI_COORD & scrollbarHandleWidth, VGUI_COORD & scrollbarHandleHeight);
  virtual void commonDrawScrollBars (Vgui_Widget const & vw);
};
class Vgui_SkinI
{
public:
  Vgui_Style Frame;
  Vgui_Style LabeledFrame;
  Vgui_Style Button;
  Vgui_Style Text;
  Vgui_Style TextEdit;
  Vgui_Style MultilineText;
  Vgui_Style ScrollBar;
  static Vgui_SkinI defaultSkin;
  Vgui_SkinI ();
  void freeDefaultStyles ();
  void initDefaultStyles ();
  virtual ~ Vgui_SkinI ();
};
typedef Vgui_SkinI Vgui_DefaultSkin;
namespace Vgui_StyleStuff
{
  LZZ_INLINE coord_element::coord_element ()
    : posMode (Vgui_PosMode::VGUI_POS_COORDINATE), value (0)
                                                                                               {}
}
namespace Vgui_StyleStuff
{
  LZZ_INLINE coord_element::coord_element (Vgui_PosMode const _pm, VGUI_COORD const _v)
    : posMode (_pm), value (_v)
                                                                                                            {}
}
namespace Vgui_StyleStuff
{
  LZZ_INLINE coord_formula::coord_formula ()
    : cachedValue (0)
                                                        {}
}
namespace Vgui_StyleStuff
{
  LZZ_INLINE coord_formula::operator VGUI_COORD () const
                                                   { return cachedValue; }
}
namespace Vgui_StyleStuff
{
  LZZ_INLINE primative::primative ()
                                   {
			#ifdef VGUI_REF_COUNT_ALLOCS
				allocCount++;
			#endif
			}
}
namespace Vgui_StyleStuff
{
  LZZ_INLINE rectPrimative::rectPrimative ()
    : primative ()
                                                     {}
}
namespace Vgui_StyleStuff
{
  LZZ_INLINE triPrimative::triPrimative ()
    : primative ()
                                                    {}
}
#undef LZZ_INLINE
#endif

////////////////////////////////////////////////////////////////////////

#ifdef VECGUI_IMPL
#ifndef VECGUI_IMPL_DOUBLE_GUARD_vgui_skin
#define VECGUI_IMPL_DOUBLE_GUARD_vgui_skin
// vgui_skin.cpp
//

#define LZZ_INLINE inline
namespace Vgui_StyleStuff
{
  colorTint::colorTint (float v)
    : r (v), g (v), b (v), a (1.f)
                                                              {}
}
namespace Vgui_StyleStuff
{
  colorTint::colorTint (float _r, float _g, float _b, float _a)
    : r (_r), g (_g), b (_b), a (_a)
                                                                                                     {}
}
namespace Vgui_StyleStuff
{
  paintInfo::paintInfo ()
    : r (VGUI_COLOR_MAX), g (VGUI_COLOR_MAX), b (VGUI_COLOR_MAX), a (VGUI_COLOR_MAX), manuallySet (false)
                                                                                                                             {}
}
namespace Vgui_StyleStuff
{
  void paintInfo::bind (colorTint const & ct) const
                                                      {
			//std::cout << "Bind: " << (r*ct.r) << ", " << (g*ct.g) << ", " << (b*ct.b) << ", " << (a*ct.a) << std::endl;
			Vgui_ContextI::aContext->setColor(r*ct.r,g*ct.g,b*ct.b,a*ct.a);
			}
}
namespace Vgui_StyleStuff
{
  void paintInfo::setF (float v)
                                   {
			r = VGUI_COLOR_MAX*v;
			g = VGUI_COLOR_MAX*v;
			b = VGUI_COLOR_MAX*v;
			a = VGUI_COLOR_MAX;
			manuallySet = true;
			}
}
namespace Vgui_StyleStuff
{
  void paintInfo::setF (float _r, float _g, float _b, float _a)
                                                                        {
			r = VGUI_COLOR_MAX*_r;
			g = VGUI_COLOR_MAX*_g;
			b = VGUI_COLOR_MAX*_b;
			a = VGUI_COLOR_MAX*_a;
			manuallySet = true;
			}
}
namespace Vgui_StyleStuff
{
  coord_formula & coord_formula::assign (Vgui_PosMode const posMode, VGUI_COORD const value)
                                                                                          {
			mElements.clear();
			addElement(posMode, value);
			return *this;
			}
}
namespace Vgui_StyleStuff
{
  coord_formula & coord_formula::addElement (Vgui_PosMode const posMode, VGUI_COORD const value)
                                                                                               {
			coord_element ce(posMode, value);
			mElements.push_back(ce);
			return *this;
			}
}
namespace Vgui_StyleStuff
{
  coord_formula & coord_formula::subElement (Vgui_PosMode const posMode, VGUI_COORD const value)
                                                                                               {
			coord_element ce(posMode, -value);
			mElements.push_back(ce);
			return *this;
			}
}
namespace Vgui_StyleStuff
{
  void coord_formula::recalcValues (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding, bool const isX)
                                                                                                                                                                                                 {
			VGUI_COORD working = isX ? px : py;
			int sz = mElements.size();
			for (int i = 0; i < sz; ++i) {				
				coord_element & ce = mElements[i];
				switch (ce.posMode) {
					case Vgui_PosMode::VGUI_POS_COORDINATE:
						working += ce.value;
						break;
					case Vgui_PosMode::VGUI_POS_EM:
						working += elementPadding*ce.value;
						break;
					case Vgui_PosMode::VGUI_POS_PERCENT:
						working += (isX ? pxs : pys)*ce.value/100.0;
						break;
					case Vgui_PosMode::VGUI_POS_TEXT_ROWS:
						working += ce.value*Vgui_ContextI::aContext->getTextLineHeight();
						break;
					case Vgui_PosMode::VGUI_POS_TEXT_LEN:
						working += ce.value*vw.text.getWidth()/100.0;
						break;
						
					}
				}
			
			cachedValue = working;
			}
}
namespace Vgui_StyleStuff
{
  void coord_formula_bbox::recalcValues (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding)
                                                                                                                                                                                 {
			x1.recalcValues(vw, vw.drawX, vw.drawY, vw.drawWidth, vw.drawHeight, elementPadding, true);
			y1.recalcValues(vw, vw.drawX, vw.drawY, vw.drawWidth, vw.drawHeight, elementPadding, false);
			x2.recalcValues(vw, vw.drawX, vw.drawY, vw.drawWidth, vw.drawHeight, elementPadding, true);
			y2.recalcValues(vw, vw.drawX, vw.drawY, vw.drawWidth, vw.drawHeight, elementPadding, false);
			}
}
namespace Vgui_StyleStuff
{
  primative::~ primative ()
                                     {
			#ifdef VGUI_REF_COUNT_ALLOCS
				allocCount--;
			#endif
			clear();
			}
}
namespace Vgui_StyleStuff
{
  void primative::updateCachedValue (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding)
                                                                                                                                                                                              {
			updateCachedValue_children(vw, px, py, pxs, pys, elementPadding);
			}
}
namespace Vgui_StyleStuff
{
  void primative::updateCachedValue_children (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding)
                                                                                                                                                                                               {
			for (auto a : childPrimatives)
				a->updateCachedValue(vw, px, py, pxs, pys, elementPadding);
			}
}
namespace Vgui_StyleStuff
{
  primative * primative::clone () const
                                                 {
			primative * r = VGUI_NEW(primative);
			base_clone(r);
			return r;
			}
}
namespace Vgui_StyleStuff
{
  void primative::base_clone (primative * r) const
                                                     {
			r->paint = paint;
			r->paintActive = paintActive;
			r->paintHover  = paintHover;
			r->paintHoverActive = paintHoverActive;
			r->childPrimatives.clear();
			for (primative* p : childPrimatives) {
				primative* pp = p->clone();
				r->childPrimatives.push_back(pp); 
				}
			}
}
namespace Vgui_StyleStuff
{
  void primative::bindPaint (Vgui_Widget const & vw, colorTint const & ct) const
                                                                                  {
			if (vw.isActive) {
				if (vw.isHovering)
					paintHoverActive.bind(ct);
				else
					paintActive.bind(ct);
				}
			else {
				if (vw.isHovering)
					paintHover.bind(ct);
				else
					paint.bind(ct);
				}
			}
}
namespace Vgui_StyleStuff
{
  void primative::draw (Vgui_Widget const & vw, colorTint const & tint) const
                                                                                       {
			drawChildren(vw, tint);
			}
}
namespace Vgui_StyleStuff
{
  void primative::drawChildren (Vgui_Widget const & vw, colorTint const & tint) const
                                                                                       {
			for (primative* p : childPrimatives)
				p->draw(vw,tint);
			}
}
namespace Vgui_StyleStuff
{
  void primative::clear ()
                             {
			for (primative* p : childPrimatives)
				VGUI_DEL(p);
			paint = paintInfo();
			paintActive = paintInfo();
			paintHover = paintInfo();
			paintHoverActive = paintInfo();
			}
}
namespace Vgui_StyleStuff
{
  void primative::fixPaint ()
                                {
			// needs to be called after setting one of the paint variables
			if (!paintActive.manuallySet)
				paintActive = paint;
			if (!paintHover.manuallySet)
				paintHover = paint;
			if (!paintHoverActive.manuallySet)
				paintHoverActive = paintActive;
				
			for (primative* p : childPrimatives)
				p->fixPaint();
			}
}
namespace Vgui_StyleStuff
{
  rectPrimative::~ rectPrimative ()
                                 {}
}
namespace Vgui_StyleStuff
{
  primative * rectPrimative::clone () const
                                          {
			rectPrimative * r = VGUI_NEW(rectPrimative);
			r->x1 = x1;
			r->y1 = y1;
			r->x2 = x2;
			r->y2 = y2;
			base_clone(r);
			return r;
			}
}
namespace Vgui_StyleStuff
{
  void rectPrimative::updateCachedValue (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding)
                                                                                                                                                                                      {
			x1.recalcValues(vw, px, py, pxs, pys, elementPadding, true);
			y1.recalcValues(vw, px, py, pxs, pys, elementPadding, false);
			x2.recalcValues(vw, px, py, pxs, pys, elementPadding, true);
			y2.recalcValues(vw, px, py, pxs, pys, elementPadding, false);
			
			updateCachedValue_children(vw, VGUI_MIN(x1,x2), VGUI_MIN(y1,y2), VGUI_ABS(x2-x1), VGUI_ABS(y2-y1), elementPadding);
			}
}
namespace Vgui_StyleStuff
{
  void rectPrimative::draw (Vgui_Widget const & vw, colorTint const & tint) const
                                                                               {
			bindPaint(vw, tint);
			Vgui_ContextI::aContext->renderQuad(x1, y1, x2, y2);
			drawChildren(vw, tint);
			}
}
namespace Vgui_StyleStuff
{
  triPrimative::~ triPrimative ()
                                {}
}
namespace Vgui_StyleStuff
{
  primative * triPrimative::clone () const
                                          {
			triPrimative * r = VGUI_NEW(triPrimative);
			r->x1 = x1;
			r->y1 = y1;
			r->x2 = x2;
			r->y2 = y2;
			r->x3 = x3;
			r->y3 = y3;
			base_clone(r);
			return r;
			}
}
namespace Vgui_StyleStuff
{
  void triPrimative::updateCachedValue (Vgui_Widget const & vw, VGUI_COORD const px, VGUI_COORD const py, VGUI_COORD const pxs, VGUI_COORD const pys, VGUI_COORD const elementPadding)
                                                                                                                                                                                      {
			x1.recalcValues(vw, px, py, pxs, pys, elementPadding, true);
			y1.recalcValues(vw, px, py, pxs, pys, elementPadding, false);
			x2.recalcValues(vw, px, py, pxs, pys, elementPadding, true);
			y2.recalcValues(vw, px, py, pxs, pys, elementPadding, false);
			x3.recalcValues(vw, px, py, pxs, pys, elementPadding, true);
			y3.recalcValues(vw, px, py, pxs, pys, elementPadding, false);
			
			VGUI_COORD mx = VGUI_MIN(VGUI_MIN(x1,x2),x3);
			VGUI_COORD my = VGUI_MIN(VGUI_MIN(y1,y2),y3);
			VGUI_COORD mmx = VGUI_MAX(VGUI_MAX(x1,x2),x3);
			VGUI_COORD mmy = VGUI_MAX(VGUI_MAX(y1,y2),y3);
			updateCachedValue_children(vw, mx, my, mmx - mx, mmy - my, elementPadding);
			}
}
namespace Vgui_StyleStuff
{
  void triPrimative::draw (Vgui_Widget const & vw, colorTint const & tint) const
                                                                               {
			bindPaint(vw, tint);
			Vgui_ContextI::aContext->renderTriangle(x1, y1, x2, y2, x3, y3);
			drawChildren(vw, tint);
			}
}
Vgui_Style::Vgui_Style ()
                      {
		elementPadding = 2;
		barWidth = 12;
		minHandleSize = 6;
		
		caretBlinkPeriod = 0.8;
		caretBlinkDutyCycle = 0.7; // Caret is on screen 70% of the time
		textAlignment = Vgui_Alignment::VGUI_LEFT;
		activeTextXNudge = 0;
		activeTextYNudge = 0;
		
		drawCaretWhenActive = false;
		isCustom = true;
		
			{
			textBBox.x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			textBBox.y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			textBBox.x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
			textBBox.y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
			}
		
			{
			yScrollbarBBox.x1.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_COORDINATE, barWidth);
			yScrollbarBBox.y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			yScrollbarBBox.x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
			yScrollbarBBox.y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
			}
			{
			xScrollbarBBox.x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			xScrollbarBBox.y1.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_COORDINATE, barWidth);
			xScrollbarBBox.x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
			xScrollbarBBox.y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
			}
			
		}
Vgui_Style::~ Vgui_Style ()
                              {
		clearPrimatives();
		}
void Vgui_Style::clearPrimatives ()
                               {
		for (Vgui_StyleStuff::primative* a : primatives) {
			VGUI_DEL(a);
			a = NULL;
			}
		primatives.clear();
		}
bool Vgui_Style::hasSamePrimatives (Vgui_Style const & other) const
                                                               {
		if (primatives.size() == other.primatives.size()) {
			for (uint32_t i = 0 ; i < primatives.size(); ++i )
				if (primatives[i] != other.primatives[i])
					return false;
			return true;
			}
		return false;
		}
void Vgui_Style::fixPaint ()
                        {
		for (Vgui_StyleStuff::primative* a : primatives)
			a->fixPaint();
		}
Vgui_Style * Vgui_Style::clone () const
                                  {
		Vgui_Style* r = VGUI_NEW(Vgui_Style);
		clone_in_place(*r, false);
		return r;
		}
void Vgui_Style::clone_in_place (Vgui_Style & target, bool const fullDestroyPrimitives) const
                                                                                         {
		if (fullDestroyPrimitives)
			target.clearPrimatives();
		
		target = *this;
		target.primatives.clear();
		
		target.primatives.reserve(primatives.size());
		for (Vgui_StyleStuff::primative* a : primatives) {
			target.primatives.push_back(a->clone());
			}
		}
void Vgui_Style::draw (Vgui_Widget & vw)
                                   {
		Vgui_StyleStuff::colorTint tint(1.f);
		for (auto a : primatives)
			a->draw(vw, tint);
		
		if (!vw.text.text.isEmpty()) {
			
		//std::cout << "text draw: " << (textBBox.x1) << " ," <<(textBBox.y1) << "[" << ((VGUI_STRING)vw.text) << "]"<< std::endl;
			VGUI_COORD dx = textBBox.x1;
			VGUI_COORD dy = textBBox.y1;
			
			if (textAlignment == Vgui_Alignment::VGUI_RIGHT)
				dx += (textBBox.x2-textBBox.x1) - vw.text.getWidth();
			if (textAlignment == Vgui_Alignment::VGUI_CENTER)
				dx += ((textBBox.x2-textBBox.x1) - vw.text.getWidth())/2;
			
			if (vw.isActive)
				{dx += activeTextXNudge; dy += activeTextYNudge;}
			
			vw.text.draw(dx, dy);
			if (vw.isActive && drawCaretWhenActive) {
				drawBlinkingCaretAt(vw.text.text, vw.caretPosition, dx, dy, 0);//Vgui_ContextI::aContext->getTextLineHeight()
				}
			}
		
		commonDrawScrollBars(vw);
		}
void Vgui_Style::drawBlinkingCaretAt (sttfont_formatted_text const & text, int caretPosition, VGUI_COORD const & textStartX, VGUI_COORD const & textStartY, VGUI_COORD const & textRowSz)
                                                                                                                                                                                     {
		if (fmod(Vgui_ContextI::aContext->getTime(), caretBlinkPeriod) < caretBlinkPeriod*caretBlinkDutyCycle) {
			Vgui_ContextI::aContext->prerenderCaretString();
			VGUI_COORD tx_caret = 0;
			VGUI_COORD ty_caret = 0;
			
			Vgui_ContextI::aContext->getTextSize(text.substr(0, caretPosition), tx_caret, ty_caret);
			Vgui_ContextI::aContext->caretString.draw(textStartX + tx_caret + Vgui_ContextI::aContext->caretKerning, textStartY + (textRowSz > 0 ? (textRowSz - ty_caret)/2 : 0));
			}
		}
void Vgui_Style::getTextStartPosTextEdit (Vgui_Widget const & vw, VGUI_COORD const & relMouseX, VGUI_COORD const & relMouseY, VGUI_COORD & posOutX, VGUI_COORD & posOutY)
                                                                                                                                                                             {
		VGUI_COORD innerPaddingT, innerPaddingB, innerPaddingL, innerPaddingR;
		getInnerPadding(vw, innerPaddingT, innerPaddingB, innerPaddingL, innerPaddingR);
		const VGUI_COORD ty = Vgui_ContextI::aContext->getTextLineHeight();
		posOutX = relMouseX - (vw.drawX + innerPaddingL - vw.xScroll);
		posOutY = relMouseY - (vw.drawY + (vw.drawHeight - ty)/2);
		}
void Vgui_Style::updateCachedValues (Vgui_Widget const & vw)
                                                        {
		for (auto a : primatives)
			a->updateCachedValue(vw, vw.drawX, vw.drawY, vw.drawWidth, vw.drawHeight, elementPadding );
		innerPaddingT.recalcValues(vw, 0, 0, vw.drawWidth, vw.drawHeight, elementPadding, false);
		innerPaddingB.recalcValues(vw, 0, 0, vw.drawWidth, vw.drawHeight, elementPadding, false);
		innerPaddingL.recalcValues(vw, 0, 0, vw.drawWidth, vw.drawHeight, elementPadding, true);
		innerPaddingR.recalcValues(vw, 0, 0, vw.drawWidth, vw.drawHeight, elementPadding, true);
		innerPaddingB_scrollBar.recalcValues(vw, 0, 0, vw.drawWidth, vw.drawHeight, elementPadding, false);
		innerPaddingR_scrollBar.recalcValues(vw, 0, 0, vw.drawWidth, vw.drawHeight, elementPadding, true);
		
		textXSizePadding.recalcValues(vw, 0, 0, vw.drawWidth, vw.drawHeight, elementPadding, true);
		textYSizePadding.recalcValues(vw, 0, 0, vw.drawWidth, vw.drawHeight, elementPadding, false);
		
		textBBox.recalcValues(vw, vw.drawX, vw.drawY, vw.drawWidth, vw.drawHeight, elementPadding);
		xScrollbarBBox.recalcValues(vw, vw.drawX, vw.drawY, vw.drawWidth, vw.drawHeight, elementPadding);
		yScrollbarBBox.recalcValues(vw, vw.drawX, vw.drawY, vw.drawWidth, vw.drawHeight, elementPadding);
		}
void Vgui_Style::getInnerPadding (Vgui_Widget const & vw, VGUI_COORD & _innerPaddingT, VGUI_COORD & _innerPaddingB, VGUI_COORD & _innerPaddingL, VGUI_COORD & _innerPaddingR)
                                                                                                                                                                         {
		_innerPaddingT = innerPaddingT;
		_innerPaddingB = innerPaddingB;
		_innerPaddingL = innerPaddingL;
		_innerPaddingR = innerPaddingR;
		
		if (vw.yScrollMax > 0)
			_innerPaddingR = innerPaddingR_scrollBar + (vw.drawX + vw.drawWidth - yScrollbarBBox.x1);
		if (vw.xScrollMax > 0)
			_innerPaddingB = innerPaddingB_scrollBar + (vw.drawY + vw.drawHeight - xScrollbarBBox.y1);
		}
void Vgui_Style::getVertScrollbarCoords (Vgui_Widget const & vw, VGUI_COORD & scrollbarX, VGUI_COORD & scrollbarY, VGUI_COORD & scrollbarWidth, VGUI_COORD & scrollbarHeight, VGUI_COORD & scrollbarHandleX, VGUI_COORD & scrollbarHandleY, VGUI_COORD & scrollbarHandleWidth, VGUI_COORD & scrollbarHandleHeight)
                          {
		//VGUI_COORD pt, pb, pl, pr;
		//vw.getStylePadding( pt, pb, pl, pr);
		
		scrollbarX = yScrollbarBBox.x1;
		scrollbarY = yScrollbarBBox.y1;
		scrollbarWidth = yScrollbarBBox.x2 - yScrollbarBBox.x1;
		scrollbarHeight = yScrollbarBBox.y2 - yScrollbarBBox.y1;
		
		if (vw.xScrollMax > 0)
			scrollbarHeight -= xScrollbarBBox.y2 - xScrollbarBBox.y1;
		
		VGUI_COORD innerHeight = scrollbarHeight - elementPadding*2;
		//VGUI_COORD innerWidth = scrollbarWidth - elementPadding*2;
	
		// Position of the bar (0.0 = begining, 1.0 = end)
		double sPos = vw.yScrollMax > vw.drawHeight ? (vw.yScroll / VGUI_MAX(vw.yScrollMax - vw.drawHeight, 0)) : 0;
		// Height of the bar (0.0 = infinitely small, 1.0 = same as frame)
		double sHeight = VGUI_MIN(double(vw.drawHeight) / vw.yScrollMax, 1.0);
		double minSHeight = double(minHandleSize) / innerHeight;
		if (sHeight < minSHeight) sHeight = minSHeight;

		VGUI_COORD grabPos = sPos * (1.0 - sHeight) * innerHeight;
		VGUI_COORD grabHeight = sHeight * innerHeight;
		
		scrollbarHandleX = scrollbarX + elementPadding;
		scrollbarHandleY = scrollbarY + elementPadding + grabPos;
		scrollbarHandleWidth = barWidth - elementPadding * 2;
		scrollbarHandleHeight = grabHeight;
		}
void Vgui_Style::getHorzScrollbarCoords (Vgui_Widget const & vw, VGUI_COORD & scrollbarX, VGUI_COORD & scrollbarY, VGUI_COORD & scrollbarWidth, VGUI_COORD & scrollbarHeight, VGUI_COORD & scrollbarHandleX, VGUI_COORD & scrollbarHandleY, VGUI_COORD & scrollbarHandleWidth, VGUI_COORD & scrollbarHandleHeight)
                          {
		VGUI_COORD pt, pb, pl, pr;
		vw.getStylePadding( pt, pb, pl, pr);
		
		scrollbarX = xScrollbarBBox.x1;
		scrollbarY = xScrollbarBBox.y1;
		scrollbarWidth = xScrollbarBBox.x2 - xScrollbarBBox.x1;
		scrollbarHeight = xScrollbarBBox.y2 - xScrollbarBBox.y1;

		if (vw.yScrollMax > 0)
			scrollbarWidth -= yScrollbarBBox.x2 - yScrollbarBBox.x1;
			
		//VGUI_COORD innerHeight = scrollbarHeight - elementPadding*2;
		VGUI_COORD innerWidth = scrollbarWidth - elementPadding*2;

		// Position of the bar (0.0 = begining, 1.0 = end)
		double sPos = vw.xScrollMax > vw.drawWidth ? (vw.xScroll / VGUI_MAX(vw.xScrollMax - vw.drawWidth, 0)) : 0;
		// Height of the bar (0.0 = infinitely small, 1.0 = same as frame)
		double sHeight = VGUI_MIN(double(vw.drawWidth) / vw.xScrollMax, 1.0);
		double minSHeight = double(minHandleSize) / innerWidth;
		if (sHeight < minSHeight) sHeight = minSHeight;

		VGUI_COORD grabPos = sPos * (1.0 - sHeight) * innerWidth;
		VGUI_COORD grabHeight = sHeight * innerWidth;
		
		scrollbarHandleX = scrollbarX + elementPadding + grabPos;
		scrollbarHandleY = scrollbarY + elementPadding;
		scrollbarHandleHeight = barWidth - elementPadding * 2;
		scrollbarHandleWidth = grabHeight;
		}
void Vgui_Style::commonDrawScrollBars (Vgui_Widget const & vw)
                                                                  {
		// Draw scroll bars
		if (vw.yScrollMax > 0) {
			VGUI_COORD scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight,
				   scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight;
			getVertScrollbarCoords( vw, scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight,
						scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight);
			
			float hl = 1.0;
			if (vw.isYScrollbarHovering) hl = 0.80;
			if (vw.isYScrollbarActive)   hl = 0.75;
			float r1 = 0.85;
			Vgui_ContextI::aContext->setColor(vw.r*r1, vw.g*r1, vw.b*r1,vw.a);
			Vgui_ContextI::aContext->renderQuadWH(scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight);
			
			r1 = 0.7*hl;
			Vgui_ContextI::aContext->setColor(vw.r*r1, vw.g*r1, vw.b*r1, vw.a); 
			Vgui_ContextI::aContext->renderQuadWH(scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight);
			}
		
		if (vw.xScrollMax > 0) {
			VGUI_COORD scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight,
				   scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight;
			getHorzScrollbarCoords( vw, scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight,
						scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight);
			
			float hl = 1.0;
			if (vw.isXScrollbarHovering) hl = 0.80;
			if (vw.isXScrollbarActive)   hl = 0.75;
			float r1 = 0.85;
			Vgui_ContextI::aContext->setColor(vw.r*r1, vw.g*r1, vw.b*r1,vw.a);
			Vgui_ContextI::aContext->renderQuadWH(scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight);
			
			r1 = 0.7*hl;
			Vgui_ContextI::aContext->setColor(vw.r*r1, vw.g*r1, vw.b*r1, vw.a); 
			Vgui_ContextI::aContext->renderQuadWH(scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight);
			}
		}
Vgui_SkinI Vgui_SkinI::defaultSkin;
Vgui_SkinI::Vgui_SkinI ()
                     {
		initDefaultStyles();
		}
void Vgui_SkinI::freeDefaultStyles ()
                                 {
		Frame.clearPrimatives();
		LabeledFrame.clearPrimatives();
		Button.clearPrimatives();
		Text.clearPrimatives();
		TextEdit.clearPrimatives();
		MultilineText.clearPrimatives();
		ScrollBar.clearPrimatives();
		}
void Vgui_SkinI::initDefaultStyles ()
                                 {
		/////////////////////////////////////////
		// Frame		
		{
		Frame.clearPrimatives();
		
		Frame.innerPaddingT.assign(Vgui_PosMode::VGUI_POS_EM, 3);
		Frame.innerPaddingB.assign(Vgui_PosMode::VGUI_POS_EM, 3);
		Frame.innerPaddingL.assign(Vgui_PosMode::VGUI_POS_EM, 3);
		Frame.innerPaddingR.assign(Vgui_PosMode::VGUI_POS_EM, 3);
		
		Frame.textXSizePadding.assign(Vgui_PosMode::VGUI_POS_EM, 4);
		
		Frame.innerPaddingR_scrollBar.assign(Vgui_PosMode::VGUI_POS_EM, 1);
		Frame.innerPaddingB_scrollBar.assign(Vgui_PosMode::VGUI_POS_EM, 1);
		
		Frame.xScrollbarBBox.x1.addElement(Vgui_PosMode::VGUI_POS_EM, 3);
		Frame.xScrollbarBBox.y1.addElement(Vgui_PosMode::VGUI_POS_EM,-3);
		Frame.xScrollbarBBox.x2.addElement(Vgui_PosMode::VGUI_POS_EM,-3);
		Frame.xScrollbarBBox.y2.addElement(Vgui_PosMode::VGUI_POS_EM,-3);
		
		Frame.yScrollbarBBox.x1.addElement(Vgui_PosMode::VGUI_POS_EM,-3);
		Frame.yScrollbarBBox.y1.addElement(Vgui_PosMode::VGUI_POS_EM, 3);
		Frame.yScrollbarBBox.x2.addElement(Vgui_PosMode::VGUI_POS_EM,-3);
		Frame.yScrollbarBBox.y2.addElement(Vgui_PosMode::VGUI_POS_EM,-3);
		
		
		Vgui_StyleStuff::rectPrimative* rp = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
		rp->paint.setF(0.9);
		rp->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		rp->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		rp->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
		rp->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
		
		Frame.primatives.push_back(rp);
		
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.7);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_EM, 2);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.75);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_EM, 2);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.65);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 2);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.6);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 2);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp->childPrimatives.push_back(rp2);
			}
		Frame.fixPaint();
		Frame.isCustom = false;
		} // Frame
		
		/////////////////////////////////////////
		// Labeled Frame		
		{
		LabeledFrame.clearPrimatives();
		Frame.clone_in_place(LabeledFrame, false);
		
		{
		Vgui_StyleStuff::rectPrimative * rp2 = (Vgui_StyleStuff::rectPrimative*) LabeledFrame.primatives[0]->childPrimatives[0];
		
		rp2->y1.assign(Vgui_PosMode::VGUI_POS_TEXT_ROWS, 0.5).subElement(Vgui_PosMode::VGUI_POS_EM, 0.5);
		rp2->y2.assign(Vgui_PosMode::VGUI_POS_TEXT_ROWS, 0.5).addElement(Vgui_PosMode::VGUI_POS_EM, 0.5);
		rp2->x2.assign(Vgui_PosMode::VGUI_POS_EM, 3);
		}

		{
		Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
		rp2->paint.setF(0.7);
		rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 5).addElement(Vgui_PosMode::VGUI_POS_TEXT_LEN, 100);
		rp2->y1.assign(Vgui_PosMode::VGUI_POS_TEXT_ROWS, 0.5).subElement(Vgui_PosMode::VGUI_POS_EM, 0.5);
		rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
		rp2->y2.assign(Vgui_PosMode::VGUI_POS_TEXT_ROWS, 0.5).addElement(Vgui_PosMode::VGUI_POS_EM, 0.5);
		LabeledFrame.primatives[0]->childPrimatives.push_back(rp2);
		}
		
		LabeledFrame.textBBox.x1.assign(Vgui_PosMode::VGUI_POS_EM, 4);
		LabeledFrame.textBBox.x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 4);
			
		((Vgui_StyleStuff::rectPrimative*) LabeledFrame.primatives[0]->childPrimatives[1])->y1.assign(Vgui_PosMode::VGUI_POS_TEXT_ROWS, 0.5).subElement(Vgui_PosMode::VGUI_POS_EM, 0.5);
		((Vgui_StyleStuff::rectPrimative*) LabeledFrame.primatives[0]->childPrimatives[3])->y1.assign(Vgui_PosMode::VGUI_POS_TEXT_ROWS, 0.5).subElement(Vgui_PosMode::VGUI_POS_EM, 0.5);
		
		
		LabeledFrame.yScrollbarBBox.y1.assign(Vgui_PosMode::VGUI_POS_TEXT_ROWS, 0.5).addElement(Vgui_PosMode::VGUI_POS_EM, 1.5);
		
		LabeledFrame.fixPaint();
		LabeledFrame.isCustom = false;
		LabeledFrame.innerPaddingT.assign(Vgui_PosMode::VGUI_POS_TEXT_ROWS, 1);
		} // Labeled Frame
		
		/////////////////////////////////////////
		// Button		
		{
		Button.clearPrimatives();
		
		Button.innerPaddingT.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		Button.innerPaddingB.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		Button.innerPaddingL.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		Button.innerPaddingR.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		
		Button.textXSizePadding.assign(Vgui_PosMode::VGUI_POS_EM, 4);
		
		Vgui_StyleStuff::rectPrimative* rp = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
		float hoverMulti = 0.9;
		float activeMulti = 0.8;
		
		rp->paint.setF(0.9);
		rp->paintHover.setF(0.9*hoverMulti);
		rp->paintActive.setF(0.9*activeMulti);
		rp->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		rp->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		rp->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
		rp->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
		
		Button.textAlignment = Vgui_Alignment::VGUI_CENTER;
		Button.activeTextXNudge = 1;
		Button.activeTextYNudge = 1;
		Button.primatives.push_back(rp);
		
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.65);
			rp2->paintHover.setF(0.65*hoverMulti);
			rp2->paintActive.setF(0.55*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.70);
			rp2->paintHover.setF(0.70*hoverMulti);
			rp2->paintActive.setF(0.50*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.55);
			rp2->paintHover.setF(0.55*hoverMulti);
			rp2->paintActive.setF(0.65*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.5);
			rp2->paintHover.setF(0.5*hoverMulti);
			rp2->paintActive.setF(0.7*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp->childPrimatives.push_back(rp2);
			}
		
		Button.fixPaint();
		Button.isCustom = false;
		} // Button
		
		
		/////////////////////////////////////////
		// Text Box		
		{
		TextEdit.clearPrimatives();
		
		TextEdit.innerPaddingT.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		TextEdit.innerPaddingB.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		TextEdit.innerPaddingL.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		TextEdit.innerPaddingR.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		
		Vgui_StyleStuff::rectPrimative* rp = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
		float hoverMulti = 0.9;
		float activeMulti = 1.05;
		
		rp->paint.setF(0.95);
		rp->paintHover.setF(0.95*hoverMulti);
		rp->paintActive.setF(0.95*activeMulti);
		rp->paintHoverActive.setF(0.95*activeMulti);
		rp->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		rp->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		rp->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
		rp->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
		
		TextEdit.drawCaretWhenActive = true;
		TextEdit.primatives.push_back(rp);
		
			{
			TextEdit.textBBox.x1.assign(Vgui_PosMode::VGUI_POS_EM, 2);
			TextEdit.textBBox.y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			TextEdit.textBBox.x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 2);
			TextEdit.textBBox.y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.55);
			rp2->paintHover.setF(0.55*hoverMulti);
			rp2->paintActive.setF(0.55*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.45);
			rp2->paintHover.setF(0.45*hoverMulti);
			rp2->paintActive.setF(0.45*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.75);
			rp2->paintHover.setF(0.75*hoverMulti);
			rp2->paintActive.setF(0.75*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.85);
			rp2->paintHover.setF(0.85*hoverMulti);
			rp2->paintActive.setF(0.85*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp->childPrimatives.push_back(rp2);
			}
		
		TextEdit.fixPaint();
		TextEdit.isCustom = false;
		} // TextEdit
		
		/////////////////////////////////////////
		// MultilineText
		{
		MultilineText.clearPrimatives();
		
		MultilineText.innerPaddingT.assign(Vgui_PosMode::VGUI_POS_EM, 2);
		MultilineText.innerPaddingB.assign(Vgui_PosMode::VGUI_POS_EM, 2);
		MultilineText.innerPaddingL.assign(Vgui_PosMode::VGUI_POS_EM, 2);
		MultilineText.innerPaddingR.assign(Vgui_PosMode::VGUI_POS_EM, 2);
		
		Vgui_StyleStuff::rectPrimative* rp = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
		float hoverMulti = 0.9;
		float activeMulti = 1.05;
		
		rp->paint.setF(0.95);
		rp->paintHover.setF(0.95*hoverMulti);
		rp->paintActive.setF(0.95*activeMulti);
		rp->paintHoverActive.setF(0.95*activeMulti);
		rp->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		rp->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
		rp->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
		rp->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100);
		
		MultilineText.drawCaretWhenActive = false; //Vgui_MultilineText handles this
		MultilineText.primatives.push_back(rp);
		
		
		MultilineText.yScrollbarBBox.x1.addElement(Vgui_PosMode::VGUI_POS_EM,-1);
		MultilineText.yScrollbarBBox.y1.addElement(Vgui_PosMode::VGUI_POS_EM, 1);
		MultilineText.yScrollbarBBox.x2.addElement(Vgui_PosMode::VGUI_POS_EM,-1);
		MultilineText.yScrollbarBBox.y2.addElement(Vgui_PosMode::VGUI_POS_EM,-1);
		
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.55);
			rp2->paintHover.setF(0.55*hoverMulti);
			rp2->paintActive.setF(0.55*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.45);
			rp2->paintHover.setF(0.45*hoverMulti);
			rp2->paintActive.setF(0.45*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.75);
			rp2->paintHover.setF(0.75*hoverMulti);
			rp2->paintActive.setF(0.75*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp->childPrimatives.push_back(rp2);
			}
			
			{
			Vgui_StyleStuff::rectPrimative* rp2 = VGUI_NEW(Vgui_StyleStuff::rectPrimative);
			rp2->paint.setF(0.85);
			rp2->paintHover.setF(0.85*hoverMulti);
			rp2->paintActive.setF(0.85*activeMulti);
			rp2->x1.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 1);
			rp2->y1.assign(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->x2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp2->y2.assign(Vgui_PosMode::VGUI_POS_PERCENT, 100).subElement(Vgui_PosMode::VGUI_POS_EM, 0);
			rp->childPrimatives.push_back(rp2);
			}
		
		MultilineText.fixPaint();
		MultilineText.isCustom = false;
		} // MultilineText
		}
Vgui_SkinI::~ Vgui_SkinI ()
                             {}
#undef LZZ_INLINE
#endif //VECGUI_IMPL_DOUBLE_GUARD_vgui_skin
#endif //VECGUI_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
// vgui_context.hh
//

#ifndef LZZ_vgui_context_hh
#define LZZ_vgui_context_hh
#define LZZ_INLINE inline
namespace vecgui
{
  struct uintQuad
  {
    unsigned int first;
    unsigned int second;
    unsigned int third;
    unsigned int forth;
    uintQuad ();
    uintQuad (unsigned int const _first);
    uintQuad (unsigned int const _first, unsigned int const _second);
    uintQuad (unsigned int const _first, unsigned int const _second, unsigned int const _thrid);
    uintQuad (unsigned int const _first, unsigned int const _second, unsigned int const _thrid, unsigned int const _forth);
  };
}
struct Vgui_PrerenderedTextI
{
  Vgui_PrerenderedTextI ();
  virtual ~ Vgui_PrerenderedTextI ();
  virtual void draw (VGUI_COORD const x, VGUI_COORD const y);
  virtual void drawWithColorMod (VGUI_COORD const x, VGUI_COORD const y, VGUI_COLOR const r, VGUI_COLOR const g, VGUI_COLOR const b, VGUI_COLOR const a = VGUI_COLOR_MAX);
  virtual VGUI_COORD getWidth () const;
  virtual VGUI_COORD getHeight () const;
};
struct Vgui_Scissor
{
  VGUI_COORD x;
  VGUI_COORD y;
  VGUI_COORD w;
  VGUI_COORD h;
  bool isNull () const;
  void setToNull ();
  Vgui_Scissor ();
};
struct Vgui_TextSubWidget
{
  sttfont_formatted_text text;
  VGUI_COLOR r;
  VGUI_COLOR g;
  VGUI_COLOR b;
  VGUI_COLOR a;
  Vgui_PrerenderedTextI * mTextPrerendered;
  bool isDummy;
  bool startsWithNewLine;
  Vgui_TextSubWidget ();
  virtual ~ Vgui_TextSubWidget ();
  bool isEmpty () const;
  void clearCache ();
  void draw (VGUI_COORD const x, VGUI_COORD const y) const;
  VGUI_COORD getWidth (VGUI_COORD * const maxWidth = NULL) const;
  VGUI_COORD getHeight (VGUI_COORD * const maxWidth = NULL) const;
  void prerender ();
  void assign (sttfont_formatted_text_item_MS t);
  void assign (sttfont_formatted_text_item const & t);
  void assign (sttfont_formatted_text_MS t);
  void assign (sttfont_formatted_text const & t);
  void requestDraw ();
  void append (VGUI_STRING const & t);
  void append (sttfont_format const & fmt);
  void append_formatted_text (sttfont_formatted_text const & _text);
  void append_formatted_text (sttfont_formatted_text_MS _text);
  void back (unsigned int const num);
  void insert (size_t const caretPosition, VGUI_STRING const & t);
  void remove (size_t const caretPosition, size_t const num);
  operator VGUI_STRING () const;
};
class Vgui_ContextI
{
public:
  Vgui_Widget * mCanvas;
  Vgui_SkinI * mSkin;
  VGUI_COORD canvasXSz;
  VGUI_COORD canvasYSz;
  VGUI_COORD scalef;
  bool redrawRq;
  VGUI_VECTOR <Vgui_Scissor> scissorStack;
  Vgui_Scissor activeScissor;
  Vgui_TextSubWidget caretString;
  VGUI_COORD caretKerning;
  Vgui_ContextI ();
  virtual ~ Vgui_ContextI ();
  static Vgui_ContextI * aContext;
  void bind ();
  void setCanvas (Vgui_Widget * _child);
  void prerenderCaretString ();
  void requestRedraw ();
  virtual void setGradient (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2, uint8_t const r1, uint8_t const g1, uint8_t const b1, uint8_t const a1, uint8_t const r2, uint8_t const g2, uint8_t const b2, uint8_t const a2);
  virtual void clearGradient ();
  Vgui_Widget * fetchElement (VGUI_TAG_TYPE const & _tag);
  bool fetchBool (VGUI_TAG_TYPE const & _tag);
  double fetchDouble (VGUI_TAG_TYPE const & _tag);
  VGUI_STRING fetchText (VGUI_TAG_TYPE const & _tag);
  virtual Vgui_PrerenderedTextI * genPrerenderedText (sttfont_formatted_text const & str) const;
  virtual void resizeCanvas (VGUI_COORD const xSz, VGUI_COORD const ySz);
  virtual void renderTriangle (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2, VGUI_COORD const x3, VGUI_COORD const y3);
  virtual void renderQuad (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2);
  virtual void renderQuadWH (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const width, VGUI_COORD const height);
  virtual void renderRoundedQuadWH (VGUI_COORD const x, VGUI_COORD const y, VGUI_COORD const w, VGUI_COORD const h, VGUI_COORD const r);
  virtual void renderArc (VGUI_COORD const originX, VGUI_COORD const originY, VGUI_COORD const radius, float const startAngle, float const endAngle);
  virtual void setColor (VGUI_COLOR const r, VGUI_COLOR const g, VGUI_COLOR const b, VGUI_COLOR const a);
  virtual void setColorF (float const r, float const g, float const b, float const a);
  virtual void clear ();
  void pushScissor (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2);
  void popScissor ();
  void updateScissor ();
  virtual void ctx_setScissor ();
  bool isScissorCulled_element (Vgui_Widget const & vw) const;
  bool isScissorCulled_region (VGUI_COORD const x, VGUI_COORD const y, VGUI_COORD const w, VGUI_COORD const h) const;
  bool isScissorCulled (Vgui_Widget const & vw) const;
  bool isScissorCulled (VGUI_COORD const x, VGUI_COORD const y, VGUI_COORD const w, VGUI_COORD const h) const;
  virtual void renderText (sttfont_formatted_text const & text, VGUI_COORD const x1, VGUI_COORD const y1);
  virtual void getTextSize (sttfont_formatted_text const & text, VGUI_COORD & widthOut, VGUI_COORD & heightOut, sttfont_lookupHint * mHint = NULL, VGUI_COORD const * const maxWidth = NULL) const;
  virtual VGUI_COORD getTextWidth (sttfont_formatted_text const & text, sttfont_lookupHint * mHint = NULL, VGUI_COORD const * const maxWidth = NULL) const;
  virtual VGUI_COORD getTextHeight (sttfont_formatted_text const & text, sttfont_lookupHint * mHint = NULL) const;
  VGUI_COORD getTextWidth_lua (sttfont_formatted_text const & text) const;
  VGUI_COORD getTextHeight_lua (sttfont_formatted_text const & text) const;
  virtual int getTextCaretPos (sttfont_formatted_text const & text, VGUI_COORD const & relativeX, VGUI_COORD const & relativeY, sttfont_lookupHint * mHint = NULL);
  virtual void breakString (sttfont_formatted_text const & stringIn, VGUI_VECTOR <sttfont_formatted_text> & arrOut, VGUI_COORD const xs, bool const tokeniseNewLines = true, VGUI_VECTOR <vecgui::uintQuad> * breakPoints = NULL);
  virtual VGUI_COORD getTextLineHeight () const;
  virtual double getTime () const;
  virtual void draw (bool const forceDraw);
  virtual void pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask);
  virtual bool processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  virtual bool processKeyEvent (int const keyId, bool const down, bool const up, bool const hold, bool const repeat);
  virtual bool processTextInputEvent (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut);
};
namespace vecgui
{
  LZZ_INLINE uintQuad::uintQuad ()
    : first (0), second (0), third (0), forth (0)
                                                                    {}
}
namespace vecgui
{
  LZZ_INLINE uintQuad::uintQuad (unsigned int const _first)
    : first (_first), second (0), third (0), forth (0)
                                                                                                  {}
}
namespace vecgui
{
  LZZ_INLINE uintQuad::uintQuad (unsigned int const _first, unsigned int const _second)
    : first (_first), second (_second), third (0), forth (0)
                                                                                                                                    {}
}
namespace vecgui
{
  LZZ_INLINE uintQuad::uintQuad (unsigned int const _first, unsigned int const _second, unsigned int const _thrid)
    : first (_first), second (_second), third (_thrid), forth (0)
                                                                                                                                                                    {}
}
namespace vecgui
{
  LZZ_INLINE uintQuad::uintQuad (unsigned int const _first, unsigned int const _second, unsigned int const _thrid, unsigned int const _forth)
    : first (_first), second (_second), third (_thrid), forth (_forth)
                                                                                                                                                                                                    {}
}
LZZ_INLINE bool Vgui_Scissor::isNull () const
                                    {
		return (x < 0) && (y < 0) && (w < 0) && (h < 0);
		}
LZZ_INLINE void Vgui_Scissor::setToNull ()
                                 {
		x = -1; y = -1; w = -1; h = -1;
		}
LZZ_INLINE Vgui_Scissor::Vgui_Scissor ()
                              { setToNull(); }
LZZ_INLINE void Vgui_ContextI::requestRedraw ()
                                    { redrawRq = true; }
LZZ_INLINE bool Vgui_ContextI::isScissorCulled (Vgui_Widget const & vw) const
                                                                   {
		return isScissorCulled_element(vw);
		}
LZZ_INLINE bool Vgui_ContextI::isScissorCulled (VGUI_COORD const x, VGUI_COORD const y, VGUI_COORD const w, VGUI_COORD const h) const
                                                                                                                           {
		return isScissorCulled_region(x, y, w, h);
		}
#undef LZZ_INLINE
#endif

////////////////////////////////////////////////////////////////////////

#ifdef VECGUI_IMPL
#ifndef VECGUI_IMPL_DOUBLE_GUARD_vgui_context
#define VECGUI_IMPL_DOUBLE_GUARD_vgui_context
// vgui_context.cpp
//

#define LZZ_INLINE inline
Vgui_PrerenderedTextI::Vgui_PrerenderedTextI ()
                                 {}
Vgui_PrerenderedTextI::~ Vgui_PrerenderedTextI ()
                                         {}
void Vgui_PrerenderedTextI::draw (VGUI_COORD const x, VGUI_COORD const y)
                                                                  {}
void Vgui_PrerenderedTextI::drawWithColorMod (VGUI_COORD const x, VGUI_COORD const y, VGUI_COLOR const r, VGUI_COLOR const g, VGUI_COLOR const b, VGUI_COLOR const a)
                                                                                                                                                                               {}
VGUI_COORD Vgui_PrerenderedTextI::getWidth () const
                                            { return 0; }
VGUI_COORD Vgui_PrerenderedTextI::getHeight () const
                                             { return 0; }
Vgui_TextSubWidget::Vgui_TextSubWidget ()
  : text (), r (VGUI_COLOR_MAX), g (VGUI_COLOR_MAX), b (VGUI_COLOR_MAX), a (VGUI_COLOR_MAX), mTextPrerendered (NULL), isDummy (false), startsWithNewLine (false)
                                                                                                                                                                                  {}
Vgui_TextSubWidget::~ Vgui_TextSubWidget ()
                                      {
		//std::cout << "~Vgui_TextSubWidget [" << text << "] " << mTextPrerendered << " " << this << std::endl;
		VGUI_DEL(mTextPrerendered);
		}
bool Vgui_TextSubWidget::isEmpty () const
                             {
		return text.isEmpty();
		}
void Vgui_TextSubWidget::clearCache ()
                           {
		if (mTextPrerendered) {
			//std::cout << "Clearing: [" << text.getString() << "]" << std::endl;
			VGUI_DEL(mTextPrerendered);
			}
		mTextPrerendered = NULL;
		}
void Vgui_TextSubWidget::draw (VGUI_COORD const x, VGUI_COORD const y) const
                                                                 {
		if (text.isEmpty() || isDummy) return;
		if (mTextPrerendered) {
			// As we are drawing directly here we need to apply scaling here
			if (r != VGUI_COLOR_MAX || g != VGUI_COLOR_MAX || b != VGUI_COLOR_MAX || a != VGUI_COLOR_MAX)
				mTextPrerendered->drawWithColorMod(Vgui_ContextI::aContext->scalef*x, Vgui_ContextI::aContext->scalef*y, r,g,b,a);
			else
				mTextPrerendered->draw(Vgui_ContextI::aContext->scalef*x, Vgui_ContextI::aContext->scalef*y);
			}
		}
VGUI_COORD Vgui_TextSubWidget::getWidth (VGUI_COORD * const maxWidth) const
                                                                      {
		if (mTextPrerendered)
			return mTextPrerendered->getWidth();
		return Vgui_ContextI::aContext->getTextWidth(text, NULL, maxWidth);
		}
VGUI_COORD Vgui_TextSubWidget::getHeight (VGUI_COORD * const maxWidth) const
                                                                       {
		if (mTextPrerendered)
			return mTextPrerendered->getWidth();
		return Vgui_ContextI::aContext->getTextWidth(text, NULL, maxWidth);
		}
void Vgui_TextSubWidget::prerender ()
                          {
		if (!mTextPrerendered && !isDummy) {
			//std::cout << "Prerendering: [" << text.getString() << "]" << std::endl;
			text.consolidateSegments();			// Remove junk
			text.setColour(sttfont_format::black);	// Set any unset colors to black
			mTextPrerendered = Vgui_ContextI::aContext->genPrerenderedText(text);
			}
		}
void Vgui_TextSubWidget::assign (sttfont_formatted_text_item_MS t)
                                                      {
		text = sttfont_formatted_text(std::move(t));
		requestDraw();
		}
void Vgui_TextSubWidget::assign (sttfont_formatted_text_item const & t)
                                                           {
		text = sttfont_formatted_text(t);
		requestDraw();
		}
void Vgui_TextSubWidget::assign (sttfont_formatted_text_MS t)
                                                 {
		text = std::move(t);
		requestDraw();
		}
void Vgui_TextSubWidget::assign (sttfont_formatted_text const & t)
                                                      {
		text = t;
		requestDraw();
		}
void Vgui_TextSubWidget::requestDraw ()
                           {
		clearCache();
		}
void Vgui_TextSubWidget::append (VGUI_STRING const & t)
                                           { text << t; requestDraw(); }
void Vgui_TextSubWidget::append (sttfont_format const & fmt)
                                                { text << fmt; }
void Vgui_TextSubWidget::append_formatted_text (sttfont_formatted_text const & _text)
                                                                         { text.append(_text); }
void Vgui_TextSubWidget::append_formatted_text (sttfont_formatted_text_MS _text)
                                                                    { text.append(std::move(_text)); }
void Vgui_TextSubWidget::back (unsigned int const num)
                                          {
		text.back(num);
		}
void Vgui_TextSubWidget::insert (size_t const caretPosition, VGUI_STRING const & t)
                                                                       {
		text.insert(caretPosition, t);
		requestDraw();
		}
void Vgui_TextSubWidget::remove (size_t const caretPosition, size_t const num)
                                                                  {
		text.remove(caretPosition, num);
		requestDraw();
		}
Vgui_TextSubWidget::operator VGUI_STRING () const
                                     { return text.getString(); }
Vgui_ContextI::Vgui_ContextI ()
  : mCanvas (NULL), mSkin (NULL), canvasXSz (100), canvasYSz (100), scalef (1.0f), redrawRq (true), caretKerning (0)
                                                                                                                            { 
		mSkin = &Vgui_SkinI::defaultSkin;
		caretString.assign("|");
		}
Vgui_ContextI::~ Vgui_ContextI ()
                                 {
		if (mCanvas) VGUI_DEL(mCanvas);
		mCanvas = NULL;
		if (aContext == this) aContext = NULL;
		}
Vgui_ContextI * Vgui_ContextI::aContext = NULL;
void Vgui_ContextI::bind ()
                    { Vgui_ContextI::aContext = this; }
void Vgui_ContextI::setCanvas (Vgui_Widget * _child)
                                              {
		mCanvas=_child;
		}
void Vgui_ContextI::prerenderCaretString ()
                                    {
		if (!caretString.mTextPrerendered) {
			caretString.prerender();
			VGUI_COORD tx, ty;
			Vgui_ContextI::aContext->getTextSize(caretString.text,tx,ty);
			caretKerning = -tx*0.5;
			}
		}
void Vgui_ContextI::setGradient (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2, uint8_t const r1, uint8_t const g1, uint8_t const b1, uint8_t const a1, uint8_t const r2, uint8_t const g2, uint8_t const b2, uint8_t const a2)
                                                                                                                                                                                                                                                                     {
		}
void Vgui_ContextI::clearGradient ()
                                     {
		}
Vgui_Widget * Vgui_ContextI::fetchElement (VGUI_TAG_TYPE const & _tag)
                                                               {
		if (!mCanvas) return NULL;
		return mCanvas->getByTag(_tag);
		}
bool Vgui_ContextI::fetchBool (VGUI_TAG_TYPE const & _tag)
                                                    {
		Vgui_Widget * vw = fetchElement(_tag);
		if (vw) return vw->value;
		return false;
		}
double Vgui_ContextI::fetchDouble (VGUI_TAG_TYPE const & _tag)
                                                        {
		Vgui_Widget * vw = fetchElement(_tag);
		if (vw) return vw->value;
		return 0.0;
		}
VGUI_STRING Vgui_ContextI::fetchText (VGUI_TAG_TYPE const & _tag)
                                                           {
		Vgui_Widget * vw = fetchElement(_tag);
		if (vw) return vw->text;
		return "";
		}
Vgui_PrerenderedTextI * Vgui_ContextI::genPrerenderedText (sttfont_formatted_text const & str) const
                                                                                                      { return NULL; }
void Vgui_ContextI::resizeCanvas (VGUI_COORD const xSz, VGUI_COORD const ySz)
                                                                              {
		canvasXSz = xSz;
		canvasYSz = ySz;
		}
void Vgui_ContextI::renderTriangle (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2, VGUI_COORD const x3, VGUI_COORD const y3)
                                                                                                                                                                   {}
void Vgui_ContextI::renderQuad (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2)
                                                                                                                     {
		renderTriangle (x1, y1, x2, y1, x2, y2);
		renderTriangle (x1, y1, x1, y2, x2, y2);
		}
void Vgui_ContextI::renderQuadWH (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const width, VGUI_COORD const height)
                                                                                                                              {
		renderQuad(x1, y1, x1 + width, y1 + height);
		}
void Vgui_ContextI::renderRoundedQuadWH (VGUI_COORD const x, VGUI_COORD const y, VGUI_COORD const w, VGUI_COORD const h, VGUI_COORD const r)
                                                                                                                                              {
		int pxc = 1; // pixel correction
		int r2 = r - pxc;
		renderQuadWH(x,y+r2,w,h-r2*2);
		renderQuadWH(x+r2,y,w-r2*2,r2);
		renderQuadWH(x+r2,y+h-r2,w-r2*2,r2);
		
		pushScissor(x, y, x+w, y+h);
		renderArc(x+r,y+h-r,r,VGUI_PI/2, VGUI_PI);
		renderArc(x+r,y+r,r,VGUI_PI,VGUI_PI*3/2);
		renderArc(x+w-r,y+h-r,r,0,VGUI_PI/2);
		renderArc(x+w-r,y+r,r,VGUI_PI*3/2,2*VGUI_PI);
		popScissor();
		}
void Vgui_ContextI::renderArc (VGUI_COORD const originX, VGUI_COORD const originY, VGUI_COORD const radius, float const startAngle, float const endAngle)
                                                                                                                                                           {
		if (startAngle > endAngle) {
			renderArc(originX, originY, radius, endAngle, startAngle);
			return;
			}
		
		#if 0
		const VGUI_COORD midAngle = (startAngle + endAngle)/2;
		VGUI_COORD xSa = scalef*radius*cos(startAngle);
		VGUI_COORD ySa = scalef*radius*sin(startAngle);
		VGUI_COORD xEa = scalef*radius*cos(endAngle);
		VGUI_COORD yEa = scalef*radius*sin(endAngle);
		
		VGUI_COORD xMa = scalef*radius*cos(midAngle);
		VGUI_COORD yMa = scalef*radius*sin(midAngle);
		
		VGUI_COORD x1a = scalef * originX;
		VGUI_COORD y1a = scalef * originY;
		
		// Get axis aligned bounding box
		int xMin = x1a;
		int yMin = y1a;
		int xMax = x1a;
		int yMax = y1a;
		for (float i = startAngle; i < endAngle; i+=0.1) { // ~7 degrees
			VGUI_COORD xt = scalef*radius*cos(i);
			VGUI_COORD yt = scalef*radius*sin(i);
			xMin = VGUI_MIN(xMin, xt);
			xMax = VGUI_MAX(xMax, xt);
			yMin = VGUI_MIN(xMin, yt);
			yMax = VGUI_MAX(xMax, yt);
			}
		
		#warning scissor test me here
		#endif
		
		// Easy (but not cheap way) - emit triangles
		// TBD - row test pixels
		VGUI_COORD xtl = originX + radius*cos(startAngle);
		VGUI_COORD ytl = originY + radius*sin(startAngle);
		for (float i = startAngle+0.1; i < endAngle; i+=0.1) {
			VGUI_COORD xt = originX + radius*cos(i);
			VGUI_COORD yt = originY + radius*sin(i);
			renderTriangle(originX, originY, xt, yt, xtl, ytl);
			xtl = xt;
			ytl = yt;
			}
		{
			VGUI_COORD xt = originX + radius*cos(endAngle);
			VGUI_COORD yt = originY + radius*sin(endAngle);
			renderTriangle(originX, originY, xt, yt, xtl, ytl);
		}
		}
void Vgui_ContextI::setColor (VGUI_COLOR const r, VGUI_COLOR const g, VGUI_COLOR const b, VGUI_COLOR const a)
                                                                                                               {}
void Vgui_ContextI::setColorF (float const r, float const g, float const b, float const a)
                                                                                            {}
void Vgui_ContextI::clear ()
                              {}
void Vgui_ContextI::pushScissor (VGUI_COORD const x1, VGUI_COORD const y1, VGUI_COORD const x2, VGUI_COORD const y2)
                                                                                                              {
		VGUI_COORD px1 = VGUI_MIN(scalef * x1, scalef * x2);
		VGUI_COORD px2 = VGUI_MAX(scalef * x1, scalef * x2);
		VGUI_COORD py1 = VGUI_MIN(scalef * y1, scalef * y2);
		VGUI_COORD py2 = VGUI_MAX(scalef * y1, scalef * y2);
		
		Vgui_Scissor r;
		r.x = px1;
		r.y = py1;
		r.w = px2;
		r.h = py2;
		scissorStack.push_back(r);
		updateScissor();
		}
void Vgui_ContextI::popScissor ()
                           {
		scissorStack.pop_back();
		updateScissor();
		}
void Vgui_ContextI::updateScissor ()
                             {
		if (!scissorStack.size()) {
			activeScissor.setToNull();
			ctx_setScissor();
			return;
			}
		VGUI_COORD xmin = VGUI_COORD_MIN_VALUE;
		VGUI_COORD xmax = VGUI_COORD_MAX_VALUE;
		VGUI_COORD ymin = VGUI_COORD_MIN_VALUE;
		VGUI_COORD ymax = VGUI_COORD_MAX_VALUE;
		for (const Vgui_Scissor & r : scissorStack) {
			if (r.x > xmin) xmin = r.x;
			if (r.y > ymin) ymin = r.y;
			if (r.w < xmax) xmax = r.w;
			if (r.h < ymax) ymax = r.h;
			}
		Vgui_Scissor r;
		r.x = xmin, r.y = ymin;
		r.w = VGUI_MAX(xmax - xmin,0), r.h = VGUI_MAX(ymax - ymin,0);
		//std::cout << "ScissorTrue: " << r.x << " " << r.y << " " << (r.x + r.w) << " " << (r.y + r.h)<< std::endl;
		activeScissor = r;
		ctx_setScissor();
		}
void Vgui_ContextI::ctx_setScissor ()
                                      {}
bool Vgui_ContextI::isScissorCulled_element (Vgui_Widget const & vw) const
                                                                    {
		if (activeScissor.isNull())
			return false;
		const Vgui_Scissor & r = activeScissor;
		
		return !(r.x <= scalef*vw.drawX && r.x+r.w >= scalef*(vw.drawX+vw.drawWidth) &&
			r.y <= scalef*vw.drawY && r.y+r.h >= scalef*(vw.drawY+vw.drawHeight));
		}
bool Vgui_ContextI::isScissorCulled_region (VGUI_COORD const x, VGUI_COORD const y, VGUI_COORD const w, VGUI_COORD const h) const
                                                                                                                           {
		if (activeScissor.isNull())
			return false;
		const Vgui_Scissor & r = activeScissor;
		
		return !(r.x <= scalef*x && r.x+r.w >= scalef*(x+w) &&
			r.y <= scalef*y && r.y+r.h >= scalef*(y+h));
		}
void Vgui_ContextI::renderText (sttfont_formatted_text const & text, VGUI_COORD const x1, VGUI_COORD const y1)
                                                                                                                {}
void Vgui_ContextI::getTextSize (sttfont_formatted_text const & text, VGUI_COORD & widthOut, VGUI_COORD & heightOut, sttfont_lookupHint * mHint, VGUI_COORD const * const maxWidth) const
                                                                                                                                                                                                         {}
VGUI_COORD Vgui_ContextI::getTextWidth (sttfont_formatted_text const & text, sttfont_lookupHint * mHint, VGUI_COORD const * const maxWidth) const
                                                                                                                                                                 {
		VGUI_COORD tw, th; getTextSize(text, tw, th, mHint, maxWidth); return tw;
		}
VGUI_COORD Vgui_ContextI::getTextHeight (sttfont_formatted_text const & text, sttfont_lookupHint * mHint) const
                                                                                                                        {
		VGUI_COORD tw, th; getTextSize(text, tw, th, mHint); return th;
		}
VGUI_COORD Vgui_ContextI::getTextWidth_lua (sttfont_formatted_text const & text) const
                                                                                {
		return getTextWidth(text);
		}
VGUI_COORD Vgui_ContextI::getTextHeight_lua (sttfont_formatted_text const & text) const
                                                                                 {
		return getTextHeight(text);
		}
int Vgui_ContextI::getTextCaretPos (sttfont_formatted_text const & text, VGUI_COORD const & relativeX, VGUI_COORD const & relativeY, sttfont_lookupHint * mHint)
                                                                                                                                                                         {
		return -1;
		}
void Vgui_ContextI::breakString (sttfont_formatted_text const & stringIn, VGUI_VECTOR <sttfont_formatted_text> & arrOut, VGUI_COORD const xs, bool const tokeniseNewLines, VGUI_VECTOR <vecgui::uintQuad> * breakPoints)
                                                                                                        {}
VGUI_COORD Vgui_ContextI::getTextLineHeight () const
                                                      { return 8.0/scalef; }
double Vgui_ContextI::getTime () const
                                       {
		return 0;
		}
void Vgui_ContextI::draw (bool const forceDraw)
                                                 {
		redrawRq = false;
		if (!mCanvas) return;
		mCanvas->updateCachedAbsValues();
		mCanvas->draw_recursive(forceDraw);
		}
void Vgui_ContextI::pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask)
                                                                                              {
		if (mCanvas) return mCanvas->pollMouseState_recursive(mouseX / scalef, mouseY / scalef, buttonMask);
		}
bool Vgui_ContextI::processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                              {
		if (mCanvas) return mCanvas->processMouseEvent_recursive(mouseX / scalef, mouseY / scalef, buttonMask, isDown);
		return false;
		}
bool Vgui_ContextI::processKeyEvent (int const keyId, bool const down, bool const up, bool const hold, bool const repeat)
                                                                                                                          {
		if (mCanvas) return mCanvas->processKeyEvent_recursive(keyId, down, up, hold, repeat);
		return false;
		}
bool Vgui_ContextI::processTextInputEvent (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut)
                                                                                                                               {
		if (mCanvas) return mCanvas->processTextInputEvent_recursive(string, evType, textOut);
		return false;
		}
#undef LZZ_INLINE
#endif //VECGUI_IMPL_DOUBLE_GUARD_vgui_context
#endif //VECGUI_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
// vgui_widget.hh
//

#ifndef LZZ_vgui_widget_hh
#define LZZ_vgui_widget_hh
#define LZZ_INLINE inline
class Vgui_EventCallbackI
{
public:
  virtual void onMouseEvent (Vgui_Widget * W, VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  virtual void onScrollbarMouseEvent (Vgui_Widget * W, VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  virtual void onKeyEvent (Vgui_Widget * W, int const keyId, bool const down, bool const up, bool const hold, bool const repeat);
  virtual void onTextInputEvent (Vgui_Widget * W, VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut);
};
class Vgui_OptionalEventCallbackI
{
public:
  Vgui_Widget * W;
  Vgui_EventCallbackI * CBI;
  Vgui_OptionalEventCallbackI (Vgui_Widget * _W, Vgui_EventCallbackI * _CBI);
  Vgui_OptionalEventCallbackI ();
  void onMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  void onScrollbarMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  void onKeyEvent (int const keyId, bool const down, bool const up, bool const hold, bool const repeat);
  void onTextInputEvent (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut);
};
class Vgui_StyleWrap
{
public:
  Vgui_Style mStyle;
};
class Vgui_Widget
{
public:
  Vgui_Widget * mParent;
  Vgui_StyleWrap mStyleWrap;
  Vgui_EventCallbackI * mEventCallback;
  VGUI_VECTOR <Vgui_Widget*> mChildren;
  VGUI_STRING tag;
  VGUI_COORD x;
  VGUI_COORD y;
  VGUI_COORD xs;
  VGUI_COORD ys;
  VGUI_COLOR r;
  VGUI_COLOR g;
  VGUI_COLOR b;
  VGUI_COLOR a;
  VGUI_COORD innerPaddingT;
  VGUI_COORD innerPaddingB;
  VGUI_COORD innerPaddingL;
  VGUI_COORD innerPaddingR;
  VGUI_COORD outerPaddingT;
  VGUI_COORD outerPaddingB;
  VGUI_COORD outerPaddingL;
  VGUI_COORD outerPaddingR;
  VGUI_COORD xScroll;
  VGUI_COORD xScrollMax;
  VGUI_COORD yScroll;
  VGUI_COORD yScrollMax;
  VGUI_COORD xScrollMaxWhenClicked;
  VGUI_COORD yScrollMaxWhenClicked;
  Vgui_Alignment horizontalAlignment;
  Vgui_Alignment verticalAlignment;
  Vgui_DimMode widthMode;
  Vgui_DimMode heightMode;
  Vgui_PosMode xPosMode;
  Vgui_PosMode yPosMode;
  Vgui_TextSubWidget text;
  double value;
  size_t caretPosition;
  size_t caretSelectionStart;
  bool isActive;
  bool isHovering;
  bool isXScrollbarActive;
  bool isXScrollbarHovering;
  bool isYScrollbarActive;
  bool isYScrollbarHovering;
  bool isAutoscrolling;
  bool isAutoscrollingActive;
  bool isDirty;
  bool makesParentDirtyIfMadeDirty;
  bool alwaysDraw;
  VGUI_COORD drawX;
  VGUI_COORD drawY;
  VGUI_COORD drawWidth;
  VGUI_COORD drawHeight;
  Vgui_Widget ();
  static Vgui_SkinI * wrangleDefaultSkin ();
  virtual Vgui_Widget * clone () const;
protected:
  Vgui_Widget * baseCloneWorker (Vgui_Widget * r) const;
public:
  virtual ~ Vgui_Widget ();
  void purgeChildren ();
  void repairLinks ();
  Vgui_Style * wrangleStyle () const;
  void setStyle (Vgui_Style const & v);
  virtual void getStylePadding (VGUI_COORD & _innerPaddingT, VGUI_COORD & _innerPaddingB, VGUI_COORD & _innerPaddingL, VGUI_COORD & _innerPaddingR) const;
  Vgui_Widget * getRoot ();
  void addChild (Vgui_Widget * _child);
  void addChildTagged (Vgui_Widget * _child, VGUI_TAG_TYPE const & _tag);
  bool removeChild (Vgui_Widget * _child, bool freeMem = true);
  void disableRecursive (bool disableHover, bool disableActive);
  Vgui_Widget * setPos (VGUI_COORD const _x, VGUI_COORD const _y);
  Vgui_Widget * setSize (VGUI_COORD const _xs, VGUI_COORD const _ys);
  Vgui_Widget * setPosAndSize (VGUI_COORD const _x, VGUI_COORD const _y, VGUI_COORD const _xs, VGUI_COORD const _ys);
  Vgui_Widget * setDimMode (Vgui_DimMode const _widthMode, Vgui_DimMode const _heightMode);
  Vgui_Widget * setDimModeBoth (Vgui_DimMode const _widthAndHeightMode);
  Vgui_Widget * setPosMode (Vgui_PosMode const _xPosMode, Vgui_PosMode const _yPosMode);
  Vgui_Widget * setPosModeBoth (Vgui_PosMode const _xAndyPosMode);
  Vgui_Widget * setWidth (VGUI_COORD const _xs);
  Vgui_Widget * setHeight (VGUI_COORD const _ys);
  Vgui_Widget * setInnerPaddingAll (VGUI_COORD const _p);
  Vgui_Widget * setOuterPaddingAll (VGUI_COORD const _p);
  Vgui_Widget * setInnerPadding (VGUI_COORD const _t, VGUI_COORD const _b, VGUI_COORD const _l, VGUI_COORD const _r);
  Vgui_Widget * setOuterPadding (VGUI_COORD const _t, VGUI_COORD const _b, VGUI_COORD const _l, VGUI_COORD const _r);
  Vgui_Widget * setText (sttfont_formatted_text const & _text);
  sttfont_formatted_text const & getText () const;
  Vgui_Widget * setColor (VGUI_COLOR const _r, VGUI_COLOR const _g, VGUI_COLOR const _b, VGUI_COLOR const _a);
  Vgui_Widget * setColorF (float const _r, float const _g, float const _b, float const _a);
  Vgui_Widget * setAlignment (Vgui_Alignment const hz, Vgui_Alignment const vt);
  Vgui_Widget * setAlignmentH (Vgui_Alignment const hz);
  Vgui_Widget * setAlignmentV (Vgui_Alignment const vt);
  Vgui_Widget * setTag (VGUI_TAG_TYPE const & _tag);
  void updateStyleCachedValues ();
  void updateCachedAbsValues ();
  Vgui_Widget * getByTag (VGUI_STRING const & searchTag);
  void markDirty ();
  bool doDraw (bool const forceDraw);
  void prerender ();
  virtual void draw (bool const forceDraw);
  virtual void draw_recursive (bool const forceDraw);
  virtual void pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask);
  virtual bool processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  virtual bool processKeyEvent (int const keyId, bool const down, bool const up, bool const hold, bool const repeat);
  virtual bool processTextInputEvent (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut);
  void pollMouseState_recursive (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask);
  bool processMouseEvent_recursive (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  bool processKeyEvent_recursive (int const keyId, bool const down, bool const up, bool const hold, bool const repeat);
  bool processTextInputEvent_recursive (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut);
  static bool isMouseInRegion (VGUI_COORD mouseX, VGUI_COORD mouseY, VGUI_COORD rX, VGUI_COORD rY, VGUI_COORD rW, VGUI_COORD rH);
  bool isMouseInElement (VGUI_COORD mouseX, VGUI_COORD mouseY);
  virtual void setCaretPosBasedOnPos (VGUI_COORD mouseX, VGUI_COORD mouseY);
  virtual void setCaretPosToEnd ();
  Vgui_OptionalEventCallbackI wrangleEventCallback (bool consumed = true);
protected:
  void hoverBehaviour_pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask);
  bool buttonBehaviour_processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  bool toggleBehaviour_processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  bool focusBehaviour_processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  bool textAreaBehaviour_processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown, bool isFirstClickCaretSetting);
  void scrollbar_pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask);
  bool scrollbar_processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
};
LZZ_INLINE bool Vgui_Widget::doDraw (bool const forceDraw)
                                                 {
		if (!VGUI_DO_DELTA_DRAWING) return true;
		if (isDirty || alwaysDraw || forceDraw) {
			isDirty = false;
			return true;
			}
		return false;
		}
#undef LZZ_INLINE
#endif

////////////////////////////////////////////////////////////////////////

#ifdef VECGUI_IMPL
#ifndef VECGUI_IMPL_DOUBLE_GUARD_vgui_widget
#define VECGUI_IMPL_DOUBLE_GUARD_vgui_widget
// vgui_widget.cpp
//

#define LZZ_INLINE inline
void Vgui_EventCallbackI::onMouseEvent (Vgui_Widget * W, VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                                          {}
void Vgui_EventCallbackI::onScrollbarMouseEvent (Vgui_Widget * W, VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                                                   {}
void Vgui_EventCallbackI::onKeyEvent (Vgui_Widget * W, int const keyId, bool const down, bool const up, bool const hold, bool const repeat)
                                                                                                                                      {}
void Vgui_EventCallbackI::onTextInputEvent (Vgui_Widget * W, VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut)
                                                                                                                                           {}
Vgui_OptionalEventCallbackI::Vgui_OptionalEventCallbackI (Vgui_Widget * _W, Vgui_EventCallbackI * _CBI)
  : W (_W), CBI (_CBI)
                                                                                                      {}
Vgui_OptionalEventCallbackI::Vgui_OptionalEventCallbackI ()
  : W (NULL), CBI (NULL)
                                                            {}
void Vgui_OptionalEventCallbackI::onMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                 { if (CBI && W) CBI->onMouseEvent(W, mouseX, mouseY, buttonMask, isDown); }
void Vgui_OptionalEventCallbackI::onScrollbarMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                          { if (CBI && W) CBI->onScrollbarMouseEvent(W, mouseX, mouseY, buttonMask, isDown); }
void Vgui_OptionalEventCallbackI::onKeyEvent (int const keyId, bool const down, bool const up, bool const hold, bool const repeat)
                                                                                                             { if (CBI && W) CBI->onKeyEvent(W, keyId, down, up, hold, repeat); }
void Vgui_OptionalEventCallbackI::onTextInputEvent (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut)
                                                                                                                  { if (CBI && W) CBI->onTextInputEvent(W, string, evType, textOut); }
Vgui_Widget::Vgui_Widget ()
  : mParent (NULL), mEventCallback (NULL)
                                                            {
		x = 0, y = 0;
		xs = 100;
		ys = 100;
		r = VGUI_COLOR_MAX, g = VGUI_COLOR_MAX, b = VGUI_COLOR_MAX, a = VGUI_COLOR_MAX;
		
		innerPaddingT = 0,innerPaddingB = 0,innerPaddingL = 0,innerPaddingR = 0;
		outerPaddingT = 0,outerPaddingB = 0,outerPaddingL = 0,outerPaddingR = 0;
		xScroll = 0, xScrollMax = 0, yScroll = 0, yScrollMax = 0; xScrollMaxWhenClicked = 0; yScrollMaxWhenClicked = 0;
		horizontalAlignment = Vgui_Alignment::VGUI_LEFT;
		verticalAlignment = Vgui_Alignment::VGUI_TOP;
		widthMode = Vgui_DimMode::VGUI_DIM_PERCENT;
		heightMode = Vgui_DimMode::VGUI_DIM_PERCENT;
		xPosMode = Vgui_PosMode::VGUI_POS_COORDINATE;
		yPosMode = Vgui_PosMode::VGUI_POS_COORDINATE;

		value = 0.0;
		caretPosition = 0;
		caretSelectionStart = size_t(-1);
	
		isActive = false;
		isHovering = false;
		isXScrollbarActive = false;
		isXScrollbarHovering = false;
		isYScrollbarActive = false;
		isYScrollbarHovering = false;
		isAutoscrolling = false;
		isAutoscrollingActive = false;
		
		makesParentDirtyIfMadeDirty = false;
		isDirty = true;
		alwaysDraw = false;

		drawX = 0;
		drawY = 0;
		drawWidth = 1;
		drawHeight = 1;
		
		setStyle(wrangleDefaultSkin()->Frame);
		}
Vgui_SkinI * Vgui_Widget::wrangleDefaultSkin ()
                                                 {
		if (Vgui_ContextI::aContext)
			if (Vgui_ContextI::aContext->mSkin) return Vgui_ContextI::aContext->mSkin;
		return &Vgui_SkinI::defaultSkin;
		}
Vgui_Widget * Vgui_Widget::clone () const
                                            {
		Vgui_Widget * r = VGUI_NEW(Vgui_Widget);
		r->mStyleWrap.mStyle.clearPrimatives();
		*r = *this;
		return baseCloneWorker(r);
		}
Vgui_Widget * Vgui_Widget::baseCloneWorker (Vgui_Widget * r) const
                                                              {
		mStyleWrap.mStyle.clone_in_place(r->mStyleWrap.mStyle, false);
		
		r->text.mTextPrerendered = NULL;
		r->mParent = NULL;
		r->mChildren.clear();
		for (const Vgui_Widget * const VW : mChildren) {
			if (VW)
				r->mChildren.push_back(VW->clone());
			}
		r->repairLinks();
		return r;
		}
Vgui_Widget::~ Vgui_Widget ()
                               {
		//mStyleWrap.clear();
		purgeChildren();
		}
void Vgui_Widget::purgeChildren ()
                             {
		for (unsigned int i = 0 ; i < mChildren.size(); ++i) {
			VGUI_DEL(mChildren[i]);
			mChildren[i] = NULL;
			}
		mChildren.clear();
		}
void Vgui_Widget::repairLinks ()
                           {
		for (unsigned int i = 0 ; i < mChildren.size(); ++i) {
			if (!mChildren[i]) {
				mChildren.erase(mChildren.begin() + i);
				--i;
				continue;
				}
			mChildren[i]->mParent = this;
			mChildren[i]->repairLinks();
			}
		}
Vgui_Style * Vgui_Widget::wrangleStyle () const
                                         {
		return const_cast<Vgui_Style*>(&mStyleWrap.mStyle);
		}
void Vgui_Widget::setStyle (Vgui_Style const & v)
                                           {
		v.clone_in_place(mStyleWrap.mStyle, true);
		}
void Vgui_Widget::getStylePadding (VGUI_COORD & _innerPaddingT, VGUI_COORD & _innerPaddingB, VGUI_COORD & _innerPaddingL, VGUI_COORD & _innerPaddingR) const
                                                                                                                                                               {
		wrangleStyle()->getInnerPadding( *this, _innerPaddingT, _innerPaddingB, _innerPaddingL, _innerPaddingR);
		}
Vgui_Widget * Vgui_Widget::getRoot ()
                                {
		if (mParent) return mParent->getRoot();
		return this;
		}
void Vgui_Widget::addChild (Vgui_Widget * _child)
                                            {
		_child->mParent = this;
		mChildren.push_back(_child);
		}
void Vgui_Widget::addChildTagged (Vgui_Widget * _child, VGUI_TAG_TYPE const & _tag)
                                                                              {
		_child->tag = _tag;
		addChild(_child);
		}
bool Vgui_Widget::removeChild (Vgui_Widget * _child, bool freeMem)
                                                                    {
		bool r = false;
		for (unsigned int i = 0 ; i < mChildren.size(); ++i) {
			r = r || mChildren[i]->removeChild(_child, false);
			if (_child == mChildren[i]) {
				mChildren.erase(mChildren.begin() + i);
				--i;
				r = true;
				}
			}
		if (r && freeMem) VGUI_DEL(_child);
		return r;
		}
void Vgui_Widget::disableRecursive (bool disableHover, bool disableActive)
                                                                     {
		for (unsigned int i = 0 ; i < mChildren.size(); ++i) {
			if (disableHover) if (mChildren[i]->isHovering) { mChildren[i]->isHovering = false; mChildren[i]->markDirty(); }
			if (disableActive) if (mChildren[i]->isActive) { mChildren[i]->isActive = false; mChildren[i]->markDirty(); }
			mChildren[i]->disableRecursive(disableHover, disableActive);
			}
		}
Vgui_Widget * Vgui_Widget::setPos (VGUI_COORD const _x, VGUI_COORD const _y)
                                                                       {
		x = _x, y = _y;
		return this;
		}
Vgui_Widget * Vgui_Widget::setSize (VGUI_COORD const _xs, VGUI_COORD const _ys)
                                                                          {
		xs = _xs, ys = _ys;
		return this;
		}
Vgui_Widget * Vgui_Widget::setPosAndSize (VGUI_COORD const _x, VGUI_COORD const _y, VGUI_COORD const _xs, VGUI_COORD const _ys)
                                                                                                                          {
		x = _x, y = _y, xs = _xs, ys = _ys;
		return this;
		}
Vgui_Widget * Vgui_Widget::setDimMode (Vgui_DimMode const _widthMode, Vgui_DimMode const _heightMode)
                                                                                                {
		widthMode = _widthMode;
		heightMode = _heightMode;
		return this;
		}
Vgui_Widget * Vgui_Widget::setDimModeBoth (Vgui_DimMode const _widthAndHeightMode)
                                                                             {
		widthMode = _widthAndHeightMode;
		heightMode = _widthAndHeightMode;
		return this;
		}
Vgui_Widget * Vgui_Widget::setPosMode (Vgui_PosMode const _xPosMode, Vgui_PosMode const _yPosMode)
                                                                                             {
		xPosMode = _xPosMode;
		yPosMode = _yPosMode;
		return this;
		}
Vgui_Widget * Vgui_Widget::setPosModeBoth (Vgui_PosMode const _xAndyPosMode)
                                                                       {
		xPosMode = _xAndyPosMode;
		yPosMode = _xAndyPosMode;
		return this;
		}
Vgui_Widget * Vgui_Widget::setWidth (VGUI_COORD const _xs)
                                                     {
		xs = _xs;
		return this;
		}
Vgui_Widget * Vgui_Widget::setHeight (VGUI_COORD const _ys)
                                                      {
		ys = _ys;
		return this;
		}
Vgui_Widget * Vgui_Widget::setInnerPaddingAll (VGUI_COORD const _p)
                                                              {
		innerPaddingT = _p, innerPaddingB = _p, innerPaddingL = _p, innerPaddingR = _p;
		return this;
		}
Vgui_Widget * Vgui_Widget::setOuterPaddingAll (VGUI_COORD const _p)
                                                              {
		outerPaddingT = _p, outerPaddingB = _p, outerPaddingL = _p, outerPaddingR = _p;
		return this;
		}
Vgui_Widget * Vgui_Widget::setInnerPadding (VGUI_COORD const _t, VGUI_COORD const _b, VGUI_COORD const _l, VGUI_COORD const _r)
                                                                                                                          {
		innerPaddingT = _t, innerPaddingB = _b, innerPaddingL = _l, innerPaddingR = _r;
		return this;
		}
Vgui_Widget * Vgui_Widget::setOuterPadding (VGUI_COORD const _t, VGUI_COORD const _b, VGUI_COORD const _l, VGUI_COORD const _r)
                                                                                                                          {
		outerPaddingT = _t, outerPaddingB = _b, outerPaddingL = _l, outerPaddingR = _r;
		return this;
		}
Vgui_Widget * Vgui_Widget::setText (sttfont_formatted_text const & _text)
                                                                    {
		text.assign(_text);
		return this;
		}
sttfont_formatted_text const & Vgui_Widget::getText () const
                                                       {
		return text.text;
		}
Vgui_Widget * Vgui_Widget::setColor (VGUI_COLOR const _r, VGUI_COLOR const _g, VGUI_COLOR const _b, VGUI_COLOR const _a)
                                                                                                                   {
		r = _r, g = _g, b = _b, a = _a;
		return this;
		}
Vgui_Widget * Vgui_Widget::setColorF (float const _r, float const _g, float const _b, float const _a)
                                                                                                {
		r = _r*VGUI_COLOR_MAX, g = _g*VGUI_COLOR_MAX, b = _b*VGUI_COLOR_MAX, a = _a*VGUI_COLOR_MAX;
		return this;
		}
Vgui_Widget * Vgui_Widget::setAlignment (Vgui_Alignment const hz, Vgui_Alignment const vt)
                                                                                     {
		horizontalAlignment = hz, verticalAlignment = vt;
		return this;
		}
Vgui_Widget * Vgui_Widget::setAlignmentH (Vgui_Alignment const hz)
                                                             {
		horizontalAlignment = hz;
		return this;
		}
Vgui_Widget * Vgui_Widget::setAlignmentV (Vgui_Alignment const vt)
                                                             {
		verticalAlignment = vt;
		return this;
		}
Vgui_Widget * Vgui_Widget::setTag (VGUI_TAG_TYPE const & _tag)
                                                         {
		tag = _tag;
		return this;
		}
void Vgui_Widget::updateStyleCachedValues ()
                                       {
		wrangleStyle()->updateCachedValues(*this);
		}
void Vgui_Widget::updateCachedAbsValues ()
                                     { 
		const VGUI_COORD drawX_before = drawX;
		const VGUI_COORD drawY_before = drawY;
		const VGUI_COORD drawWidth_before = drawWidth;
		const VGUI_COORD drawHeight_before = drawHeight;
		
		if (!mParent) {
			drawX = x, drawY = y;
			drawWidth = xs, drawHeight = ys;
			if (widthMode == Vgui_DimMode::VGUI_DIM_PERCENT) drawWidth = xs * Vgui_ContextI::aContext->canvasXSz * 0.01;
			if (heightMode == Vgui_DimMode::VGUI_DIM_PERCENT) drawHeight = ys * Vgui_ContextI::aContext->canvasYSz * 0.01;
			if (xPosMode == Vgui_PosMode::VGUI_POS_PERCENT) drawX = x * Vgui_ContextI::aContext->canvasXSz * 0.01;
			if (yPosMode == Vgui_PosMode::VGUI_POS_PERCENT) drawY = y * Vgui_ContextI::aContext->canvasYSz * 0.01;
		
			for (auto vgw : mChildren)
				vgw->updateCachedAbsValues();
				
			if (drawX != drawX_before || drawY != drawY_before || drawWidth != drawWidth_before || drawHeight != drawHeight_before)
				markDirty(); // redraw on resize
			updateStyleCachedValues();
			return;
			}
	
		const VGUI_COORD rowSz = Vgui_ContextI::aContext->getTextLineHeight();
		VGUI_COORD ipeT, ipeB, ipeL, ipeR;
		mParent->getStylePadding( ipeT, ipeB, ipeL, ipeR);
		
		drawX = mParent->drawX + mParent->innerPaddingL - mParent->xScroll + ipeL;
		drawY = mParent->drawY + mParent->innerPaddingT - mParent->yScroll + ipeT;
		drawWidth = xs;
		drawHeight = ys;
	
		VGUI_COORD parentInnerWidth  = VGUI_MAX(mParent->drawWidth,  mParent->xScrollMax) - mParent->innerPaddingL - mParent->innerPaddingR - ipeL - ipeR;
		VGUI_COORD parentInnerHeight = VGUI_MAX(mParent->drawHeight, mParent->yScrollMax) - mParent->innerPaddingT - mParent->innerPaddingB - ipeT - ipeB;
		bool isSizeDependentOnText = ((widthMode == Vgui_DimMode::VGUI_DIM_TEXT) || (heightMode == Vgui_DimMode::VGUI_DIM_TEXT));
		if (isSizeDependentOnText) {
			VGUI_COORD txs, tys;
			Vgui_ContextI::aContext->getTextSize(text.text, txs, tys);
			VGUI_COORD iteT, iteB, iteL, iteR;
			getStylePadding( iteT, iteB, iteL, iteR);
			
			if (widthMode == Vgui_DimMode::VGUI_DIM_TEXT)
				xs = txs + iteL + iteR + wrangleStyle()->textXSizePadding;
			if (heightMode == Vgui_DimMode::VGUI_DIM_TEXT)
				ys = tys + iteT + iteB + wrangleStyle()->textYSizePadding;
			}
		if (widthMode == Vgui_DimMode::VGUI_DIM_PERCENT) drawWidth = xs * parentInnerWidth * 0.01;
		if (heightMode == Vgui_DimMode::VGUI_DIM_PERCENT) drawHeight = ys * parentInnerHeight * 0.01;
		
		if (widthMode == Vgui_DimMode::VGUI_DIM_TEXT_ROWS) {
			if (xs >= 0) drawWidth = xs * rowSz;
			else 		 drawWidth = parentInnerWidth + xs * rowSz;
			}
		if (heightMode == Vgui_DimMode::VGUI_DIM_TEXT_ROWS) {
			if (ys >= 0) drawHeight = ys * rowSz;
			else 		 drawHeight = parentInnerHeight + ys * rowSz;
			}
		
		//if (xs > parentInnerWidth) xs = parentInnerWidth;
		//if (ys > parentInnerHeight) ys = parentInnerHeight;

		VGUI_COORD xt = x;
		VGUI_COORD yt = y;
		if (xPosMode == Vgui_PosMode::VGUI_POS_PERCENT) xt = x * parentInnerWidth * 0.01;
		if (yPosMode == Vgui_PosMode::VGUI_POS_PERCENT) yt = y * parentInnerHeight * 0.01;
		if (xPosMode == Vgui_PosMode::VGUI_POS_TEXT_ROWS) {
			if (x >= 0) xt = x * rowSz;
			else 		xt = parentInnerWidth + x * rowSz;
			}
		if (yPosMode == Vgui_PosMode::VGUI_POS_TEXT_ROWS) {
			if (y >= 0) yt = y * rowSz;
			else 		yt = parentInnerHeight + y * rowSz;
			}

		if (horizontalAlignment == Vgui_Alignment::VGUI_CENTER)
			drawX = drawX + xt + (parentInnerWidth - drawWidth) * 0.5;
		else if (horizontalAlignment == Vgui_Alignment::VGUI_RIGHT)
			drawX = drawX - xt + (parentInnerWidth - drawWidth);
		else drawX += xt;

		if (verticalAlignment == Vgui_Alignment::VGUI_CENTER)
			drawY = drawY + yt + (parentInnerHeight - drawHeight) * 0.5;
		else if (verticalAlignment == Vgui_Alignment::VGUI_BOTTOM)
			drawY = drawY - yt + (parentInnerHeight - drawHeight);
		else drawY += yt;

		bool isContainer = ((widthMode == Vgui_DimMode::VGUI_DIM_CHILD) || (heightMode == Vgui_DimMode::VGUI_DIM_CHILD));
		if (isContainer) {
			// Set size based on children
			// Not yet implemented
			}
		//std::cout << "UCA " << yt << " y: " << y << ", innerHeight: " << parentInnerHeight << std::endl;

		for (auto vgw : mChildren)
			vgw->updateCachedAbsValues();
			
		if (drawX != drawX_before || drawY != drawY_before || drawWidth != drawWidth_before || drawHeight != drawHeight)
			markDirty(); // redraw on resize
		updateStyleCachedValues();
		}
Vgui_Widget * Vgui_Widget::getByTag (VGUI_STRING const & searchTag)
                                                              {
		if (tag == searchTag) return this;
		for (auto vgw : mChildren) {
			if (vgw->tag == searchTag) return vgw;
			Vgui_Widget * R = vgw->getByTag(searchTag);
			if (R) return R;
			}
		return NULL;
		}
void Vgui_Widget::markDirty ()
                         {
		if (!VGUI_DO_DELTA_DRAWING) return;
		isDirty = true;
		if (makesParentDirtyIfMadeDirty)
			if (mParent)
				mParent->markDirty();
		}
void Vgui_Widget::prerender ()
                         {
		/// prerenders text recusively
		text.prerender();
		for (auto vgw : mChildren) vgw->prerender();
		}
void Vgui_Widget::draw (bool const forceDraw)
                                                 {
		}
void Vgui_Widget::draw_recursive (bool const forceDraw)
                                                           {
		text.prerender();
		bool subForceDraw = (isDirty || alwaysDraw || forceDraw);
		//if (isDirty) std::cout << "I'm dirty! " << tag << std::endl;
		draw(forceDraw);
			
		VGUI_COORD ipeL, ipeR, ipeT, ipeB;
		getStylePadding( ipeT, ipeB, ipeL, ipeR);
		
		Vgui_ContextI::aContext->pushScissor(drawX + ipeL, drawY + ipeT, drawX + drawWidth - ipeR, drawY + drawHeight - ipeB);
		for (auto vgw : mChildren) vgw->draw_recursive(subForceDraw);
		Vgui_ContextI::aContext->popScissor();
		
		isDirty = false;
		}
void Vgui_Widget::pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask)
                                                                                              {}
bool Vgui_Widget::processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                              {
		return false;
		}
bool Vgui_Widget::processKeyEvent (int const keyId, bool const down, bool const up, bool const hold, bool const repeat)
                                                                                                                          {
		return false;
		}
bool Vgui_Widget::processTextInputEvent (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut)
                                                                                                                               {
		return false;
		}
void Vgui_Widget::pollMouseState_recursive (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask)
                                                                                                {
		pollMouseState(mouseX, mouseY, buttonMask);
		for (auto vgw : mChildren) {
				vgw->pollMouseState_recursive(mouseX, mouseY, buttonMask);
			}
		}
bool Vgui_Widget::processMouseEvent_recursive (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                                {
		if (processMouseEvent(mouseX, mouseY, buttonMask, isDown)) return true;
		for (auto vgw : mChildren) {
			if (vgw->processMouseEvent_recursive(mouseX, mouseY, buttonMask, isDown)) return true;
			}
		return false;
		}
bool Vgui_Widget::processKeyEvent_recursive (int const keyId, bool const down, bool const up, bool const hold, bool const repeat)
                                                                                                                            {
		if (processKeyEvent(keyId, down, up, hold, repeat)) return true;
		for (auto vgw : mChildren) {
			if (vgw->processKeyEvent_recursive(keyId, down, up, hold, repeat)) return true;
			}
		return false;
		}
bool Vgui_Widget::processTextInputEvent_recursive (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut)
                                                                                                                                 {
		if (processTextInputEvent(string, evType, textOut)) return true;
		for (auto vgw : mChildren) {
			if (vgw->processTextInputEvent_recursive(string, evType, textOut)) return true;
			}
		return false;
		}
bool Vgui_Widget::isMouseInRegion (VGUI_COORD mouseX, VGUI_COORD mouseY, VGUI_COORD rX, VGUI_COORD rY, VGUI_COORD rW, VGUI_COORD rH)
                                                                                                                                      {
		return (mouseX >= rX && mouseY >= rY &&
			mouseX <= rX + rW &&
			mouseY <= rY + rH);		
		}
bool Vgui_Widget::isMouseInElement (VGUI_COORD mouseX, VGUI_COORD mouseY)
                                                                     {
		return isMouseInRegion (mouseX, mouseY, drawX, drawY, drawWidth, drawHeight);
		}
void Vgui_Widget::setCaretPosBasedOnPos (VGUI_COORD mouseX, VGUI_COORD mouseY)
                                                                                 {
		// Search for the carret position
		caretPosition = Vgui_ContextI::aContext->getTextCaretPos(text.text, mouseX - drawX, mouseY - drawY);
		if (caretPosition > text.text.size()) caretPosition = text.text.size();
		}
void Vgui_Widget::setCaretPosToEnd ()
                                        {
		caretPosition = text.text.size();
		}
Vgui_OptionalEventCallbackI Vgui_Widget::wrangleEventCallback (bool consumed)
                                                                               {
		if (!consumed) return Vgui_OptionalEventCallbackI(); // If not consumed return nothing and threfore do not callback
		Vgui_EventCallbackI * CBI = mEventCallback;
		Vgui_Widget * w = this;
		while (w && !CBI) {
			CBI = w->mEventCallback;
			w = w->mParent;
			}
		return Vgui_OptionalEventCallbackI(this, CBI);
		}
void Vgui_Widget::hoverBehaviour_pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask)
                                                                                                     {
		bool isHovering_start = isHovering;
		isHovering = (isMouseInElement(mouseX, mouseY));
		
		if (isHovering != isHovering_start)
			markDirty();
		}
bool Vgui_Widget::buttonBehaviour_processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                                      {
		bool consumed = false;
		if (buttonMask & VGUI_MB_LEFT) {
			bool isInside = isMouseInElement(mouseX, mouseY);
			if (isDown && isInside) {
				isActive = true;
				consumed = true;
				}
			if (isActive && !isDown) {
				if (isInside) // Releasing a click outside of the button counts as cancelling
					value = 1.0;
				isActive = false;
				consumed = true;
				}
			}
		wrangleEventCallback(consumed).onMouseEvent(mouseX, mouseY, buttonMask, isDown);
		if (consumed) markDirty();
		return consumed;
		}
bool Vgui_Widget::toggleBehaviour_processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                                      {
		bool consumed = false;
		if (buttonMask & VGUI_MB_LEFT) {
			bool isInside = isMouseInElement(mouseX, mouseY);
			if (isDown && isInside) {
				isActive = !isActive;
				consumed = true;
				}
			else if (isDown && !isInside) {
				isActive = false; // Does not consume!
				}
			}
		wrangleEventCallback(consumed).onMouseEvent(mouseX, mouseY, buttonMask, isDown);
		if (consumed) markDirty();
		return consumed;
		}
bool Vgui_Widget::focusBehaviour_processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                                     {
		// For things such as drop-down menus
		bool consumed = toggleBehaviour_processMouseEvent(mouseX, mouseY, buttonMask, isDown);
		if (consumed && isActive) {
			Vgui_Widget * R = getRoot();
			R->disableRecursive(false, true); 
			isActive = true;
			}
		wrangleEventCallback(consumed).onMouseEvent(mouseX, mouseY, buttonMask, isDown);
		if (consumed) markDirty();
		return consumed;
		}
bool Vgui_Widget::textAreaBehaviour_processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown, bool isFirstClickCaretSetting)
                                                                                                                                                       {
		// First click = activate
		// Second click = set carat position
		// Click outside = reset
		bool consumed = false;
		if (buttonMask & VGUI_MB_LEFT) {
			bool isInside = isMouseInElement(mouseX, mouseY) && !isXScrollbarHovering && !isYScrollbarHovering;
			if (isDown && isInside) {
				bool doCaretPos = false;
				if (!isActive)
					doCaretPos = (isFirstClickCaretSetting);
				else
					doCaretPos = true;
				
				isActive = true;
				Vgui_Widget * R = getRoot();
				R->disableRecursive(false, true); 
				isActive = true;
				
				if (doCaretPos)
					setCaretPosBasedOnPos(mouseX, mouseY);
				else
					setCaretPosToEnd();
					
				consumed = true;
				}
			else if (isDown && !isInside) {
				isActive = false; // Does not consume!
				setCaretPosToEnd();
				}
			}
		wrangleEventCallback(consumed).onMouseEvent(mouseX, mouseY, buttonMask, isDown);
		if (consumed) markDirty();
		return consumed;
		}
void Vgui_Widget::scrollbar_pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask)
                                                                                                {
		VGUI_COORD scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight,
			scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight;
			
		bool isXScrollbarHovering_start = isXScrollbarHovering;
		bool isYScrollbarHovering_start = isYScrollbarHovering;
		bool isXScrollbarActive_start = isXScrollbarActive;
		bool isYScrollbarActive_start = isYScrollbarActive;
		VGUI_COORD yScrollStart = yScroll;
		VGUI_COORD xScrollStart = xScroll;
		
		isXScrollbarHovering = false;
		isYScrollbarHovering = false;
		
		
		if (yScrollMax > 0) {	
			wrangleStyle()->getVertScrollbarCoords(*this, scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight,
					scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight);
			if (isMouseInRegion(mouseX, mouseY, scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight))
				isYScrollbarHovering = true;
			if (isYScrollbarActive) {
				VGUI_COORD maxY = VGUI_MAX(0, yScrollMaxWhenClicked - drawHeight);
				VGUI_COORD maxYReal = VGUI_MAX(0, yScrollMax - drawHeight);
				VGUI_COORD begin = scrollbarY + scrollbarHandleHeight/2;
				VGUI_COORD end = scrollbarY + scrollbarHeight - scrollbarHandleHeight/2;
				VGUI_COORD dist = end - begin;
			
				yScroll = (mouseY - begin)*maxY/VGUI_MAX(dist,1);
				yScroll = VGUI_CLAMP(yScroll, 0, maxYReal);
				}
			}
		if (xScrollMax > 0) {				
			wrangleStyle()->getHorzScrollbarCoords(*this, scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight,
				scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight);
			if (isMouseInRegion(mouseX, mouseY, scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight))
				isXScrollbarHovering = true;
			if (isXScrollbarActive) {
				VGUI_COORD maxX = VGUI_MAX(0, xScrollMaxWhenClicked - drawWidth);
				VGUI_COORD maxXReal = VGUI_MAX(0, xScrollMax - drawWidth);
				VGUI_COORD begin = scrollbarX + scrollbarHandleWidth/2;
				VGUI_COORD end = scrollbarX + scrollbarWidth - scrollbarHandleWidth/2;
				VGUI_COORD dist = end - begin;
			
				xScroll = (mouseX - begin)*maxX/VGUI_MAX(dist,1);
				xScroll = VGUI_CLAMP(xScroll, 0, maxXReal);
				}
			}
		// This block is the same as in scrollbar_processMouseEvent
		if (isAutoscrolling) {
			if (isYScrollbarActive)
				isAutoscrollingActive = false;
			else if (!isAutoscrollingActive && isYScrollbarActive_start) {
				std::cout << "AUTOSCROLL 1: " << yScroll+drawHeight << " " << VGUI_MIN(yScrollMax, yScrollMaxWhenClicked) << std::endl;
				if (yScroll+drawHeight >= VGUI_MIN(yScrollMax, yScrollMaxWhenClicked))
					isAutoscrollingActive = true;
				}
			}
			
		
		if ( isXScrollbarHovering_start != isXScrollbarHovering || isYScrollbarHovering_start != isYScrollbarHovering || isXScrollbarActive_start != isXScrollbarActive || isYScrollbarActive_start != isYScrollbarActive  || yScrollStart != yScroll || xScrollStart != xScroll)
			markDirty();
			
		}
bool Vgui_Widget::scrollbar_processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                                {
		// Check for scroll bar
		bool consumed = false;
		bool isXScrollbarHovering_start = isXScrollbarHovering;
		bool isYScrollbarHovering_start = isYScrollbarHovering;
		bool isXScrollbarActive_start = isXScrollbarActive;
		bool isYScrollbarActive_start = isYScrollbarActive;
		VGUI_COORD yScrollStart = yScroll;
		VGUI_COORD xScrollStart = xScroll;
		
		// Reset scrollbar on mb release
		if (isXScrollbarActive && (buttonMask & VGUI_MB_LEFT) && !isDown) {
			isXScrollbarActive = false;
			consumed = true;
			}
		if (isYScrollbarActive && (buttonMask & VGUI_MB_LEFT) && !isDown) {
			isYScrollbarActive = false;
			consumed = true;
			}
		
		//if (tag.size())
		//std::cout << "\n[" << tag <<  "] isXScrollbarActive " << isXScrollbarActive << " isYScrollbarActive " << isYScrollbarActive
		//		<< ",atsTart " << isYScrollbarActiveStart << " ysm: " << yScrollMax << ", isDown " << isDown
		//		<< ", isActive: " << isActive << ", isHovering: " << isHovering <<  " " << __PRETTY_FUNCTION__ << std::endl;
		
		
		if ((buttonMask & VGUI_MB_LEFT) && isDown && (yScrollMax > 0 || xScrollMax > 0)) {
			VGUI_COORD scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight,
				scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight;	
			if (yScrollMax > 0) {
				wrangleStyle()->getVertScrollbarCoords(*this, scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight,
						scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight);

				if (isMouseInRegion(mouseX, mouseY, scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight)) {
					isYScrollbarHovering = true;
					consumed = true;
					}
				if (buttonMask && isYScrollbarHovering) {
					isYScrollbarActive = true;
					}
				if (isYScrollbarActive) {
					yScrollMaxWhenClicked = yScrollMax;	// This is set for the case where this resizes while the user is scrolling
					VGUI_COORD maxY = VGUI_MAX(0, yScrollMax - drawHeight);
					VGUI_COORD begin = scrollbarY + scrollbarHandleHeight/2;
					VGUI_COORD end = scrollbarY + scrollbarHeight - scrollbarHandleHeight/2;
					VGUI_COORD dist = end - begin;
					
					yScroll = (mouseY - begin)*maxY/VGUI_MAX(dist,1);
					yScroll = VGUI_CLAMP(yScroll, 0, maxY);
					}
				}
			if (xScrollMax > 0) {
				wrangleStyle()->getHorzScrollbarCoords(*this, scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight,
						scrollbarHandleX, scrollbarHandleY, scrollbarHandleWidth, scrollbarHandleHeight);
				if (isMouseInRegion(mouseX, mouseY, scrollbarX, scrollbarY, scrollbarWidth, scrollbarHeight)) {
					isXScrollbarActive = true;
					consumed = true;
					}
				if (isXScrollbarActive) {
					xScrollMaxWhenClicked = xScrollMax;
					VGUI_COORD maxX = VGUI_MAX(0, xScrollMax - drawWidth);
					VGUI_COORD begin = scrollbarX + scrollbarHandleWidth/2;
					VGUI_COORD end = scrollbarX + scrollbarWidth - scrollbarHandleWidth/2;
					VGUI_COORD dist = end - begin;
				
					xScroll = (mouseX - begin)*maxX/VGUI_MAX(dist,1);
					xScroll = VGUI_CLAMP(xScroll, 0, maxX);
					}
				}
	
			}

		wrangleEventCallback(consumed).onMouseEvent(mouseX, mouseY, buttonMask, isDown);
		if (isAutoscrolling) {
			if (isYScrollbarActive)
				isAutoscrollingActive = false;
			else if (!isAutoscrollingActive && isYScrollbarActive_start) {
				std::cout << "AUTOSCROLL 2: " << yScroll+drawHeight << " " << VGUI_MIN(yScrollMax, yScrollMaxWhenClicked) << std::endl;
				if (yScroll+drawHeight >= VGUI_MIN(yScrollMax, yScrollMaxWhenClicked))
					isAutoscrollingActive = true;
				}
			}
		
		wrangleEventCallback(consumed).onScrollbarMouseEvent(mouseX, mouseY, buttonMask, isDown);
		
		if ( isXScrollbarHovering_start != isXScrollbarHovering || isYScrollbarHovering_start != isYScrollbarHovering || isXScrollbarActive_start != isXScrollbarActive || isYScrollbarActive_start != isYScrollbarActive  || yScrollStart != yScroll || xScrollStart != xScroll)
			markDirty();
		else if (consumed)
			markDirty();
			
		if (consumed) return true; // ??
			
		if (!buttonMask) {
			isXScrollbarActive = false;
			isYScrollbarActive = false;
			}
		isXScrollbarHovering = false;
		isYScrollbarHovering = false;
		return consumed;
		}
#undef LZZ_INLINE
#endif //VECGUI_IMPL_DOUBLE_GUARD_vgui_widget
#endif //VECGUI_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
// vgui_elements.hh
//

#ifndef LZZ_vgui_elements_hh
#define LZZ_vgui_elements_hh
#define LZZ_INLINE inline
class Vgui_Frame : public Vgui_Widget
{
public:
  Vgui_Frame ();
  virtual Vgui_Widget * clone () const;
  Vgui_Frame (VGUI_STRING const & _text);
  void draw (bool const forceDraw);
  void pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask);
  bool processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
};
class Vgui_Button : public Vgui_Widget
{
public:
  Vgui_Button ();
  Vgui_Button (VGUI_STRING const & _text);
  virtual Vgui_Widget * clone () const;
  void draw (bool const forceDraw);
  void pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask);
  bool processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
};
class Vgui_Text : public Vgui_Widget
{
public:
  Vgui_Text ();
  Vgui_Text (VGUI_STRING const & _text);
  virtual Vgui_Widget * clone () const;
  void draw (bool const forceDraw);
};
class Vgui_TextEdit : public Vgui_Widget
{
public:
  Vgui_TextEdit ();
  Vgui_TextEdit (VGUI_STRING const & _text);
  virtual Vgui_Widget * clone () const;
  void draw (bool const forceDraw);
  void setCaretPosBasedOnPos (VGUI_COORD mouseX, VGUI_COORD mouseY);
  void updateScrolling ();
  void pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask);
  bool processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  bool processTextInputEvent (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut);
};
#undef LZZ_INLINE
#endif

////////////////////////////////////////////////////////////////////////

#ifdef VECGUI_IMPL
#ifndef VECGUI_IMPL_DOUBLE_GUARD_vgui_elements
#define VECGUI_IMPL_DOUBLE_GUARD_vgui_elements
// vgui_elements.cpp
//

#define LZZ_INLINE inline
Vgui_Frame::Vgui_Frame ()
  : Vgui_Widget ()
                                     {}
Vgui_Widget * Vgui_Frame::clone () const
                                            {
		Vgui_Frame * r = VGUI_NEW(Vgui_Frame);
		r->mStyleWrap.mStyle.clearPrimatives();
		*r = *this;
		return baseCloneWorker(r);
		}
Vgui_Frame::Vgui_Frame (VGUI_STRING const & _text)
  : Vgui_Widget ()
                                                              { text.assign(_text); }
void Vgui_Frame::draw (bool const forceDraw)
                                         {
		if (doDraw(forceDraw))
			wrangleStyle()->draw(*this);
		}
void Vgui_Frame::pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask)
                                                                                      {
		scrollbar_pollMouseState(mouseX, mouseY, buttonMask);
		}
bool Vgui_Frame::processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                      {
		// Check for scroll bar
		bool consumed = scrollbar_processMouseEvent(mouseX, mouseY, buttonMask, isDown);
		if (consumed) return consumed;
		return Vgui_Widget::processMouseEvent(mouseX, mouseY, buttonMask, isDown);
		}
Vgui_Button::Vgui_Button ()
  : Vgui_Widget ()
                                      {
		heightMode = Vgui_DimMode::VGUI_DIM_TEXT_ROWS; ys = 1;
		setStyle(wrangleDefaultSkin()->Button);
		}
Vgui_Button::Vgui_Button (VGUI_STRING const & _text)
  : Vgui_Widget ()
                                                               { 
		text.assign(_text);
		heightMode = Vgui_DimMode::VGUI_DIM_TEXT_ROWS; ys = 1;
		setStyle(wrangleDefaultSkin()->Button);
		}
Vgui_Widget * Vgui_Button::clone () const
                                            {
		Vgui_Button * r = VGUI_NEW(Vgui_Button);
		r->mStyleWrap.mStyle.clearPrimatives();
		*r = *this;
		return baseCloneWorker(r);
		}
void Vgui_Button::draw (bool const forceDraw)
                                         {
		if (doDraw(forceDraw))
			wrangleStyle()->draw(*this);
		}
void Vgui_Button::pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask)
                                                                                      {
		hoverBehaviour_pollMouseState(mouseX, mouseY, buttonMask);
		}
bool Vgui_Button::processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                      {
		return buttonBehaviour_processMouseEvent(mouseX, mouseY, buttonMask, isDown);
		}
Vgui_Text::Vgui_Text ()
  : Vgui_Widget ()
                                    {
		widthMode = Vgui_DimMode::VGUI_DIM_TEXT; heightMode = Vgui_DimMode::VGUI_DIM_TEXT;
		setStyle(wrangleDefaultSkin()->Text);
		makesParentDirtyIfMadeDirty = true;
		}
Vgui_Text::Vgui_Text (VGUI_STRING const & _text)
  : Vgui_Widget ()
                                                             {
		widthMode = Vgui_DimMode::VGUI_DIM_TEXT;
		heightMode = Vgui_DimMode::VGUI_DIM_TEXT;
		setText(_text);
		setStyle(wrangleDefaultSkin()->Text);
		makesParentDirtyIfMadeDirty = true;
		}
Vgui_Widget * Vgui_Text::clone () const
                                            {
		Vgui_Text * r = VGUI_NEW(Vgui_Text);
		r->mStyleWrap.mStyle.clearPrimatives();
		*r = *this;
		return baseCloneWorker(r);
		}
void Vgui_Text::draw (bool const forceDraw)
                                         {
		//std::cout << bool(!VGUI_DO_DELTA_DRAWING) << " " << (isDirty) << " " << alwaysDraw << " " << forceDraw << std::endl;
		
		if (doDraw(forceDraw)) {
			wrangleStyle()->draw(*this);
			//std::cout << ("drawtext! [") << text.text.getString() << "]" << std::endl;
			}
		}
Vgui_TextEdit::Vgui_TextEdit ()
  : Vgui_Widget ()
                                        {
		setStyle(wrangleDefaultSkin()->TextEdit);
		}
Vgui_TextEdit::Vgui_TextEdit (VGUI_STRING const & _text)
  : Vgui_Widget ()
                                                                 {
		text.assign(_text);
		setStyle(wrangleDefaultSkin()->TextEdit);
		}
Vgui_Widget * Vgui_TextEdit::clone () const
                                            {
		Vgui_TextEdit * r = VGUI_NEW(Vgui_TextEdit);
		r->mStyleWrap.mStyle.clearPrimatives();
		*r = *this;
		return baseCloneWorker(r);
		}
void Vgui_TextEdit::draw (bool const forceDraw)
                                         {
		if (isActive) {
			markDirty();
			}
		if (doDraw(forceDraw))
			wrangleStyle()->draw(*this);
		}
void Vgui_TextEdit::setCaretPosBasedOnPos (VGUI_COORD mouseX, VGUI_COORD mouseY)
                                                                         {
		// Do a binary search for the closest location
		VGUI_COORD mouseTextRelX, mouseTextRelY;
		wrangleStyle()->getTextStartPosTextEdit(*this, mouseX, mouseY, mouseTextRelX, mouseTextRelY);
		
		caretPosition = Vgui_ContextI::aContext->getTextCaretPos(text.text, mouseTextRelX, mouseTextRelY );
		if (caretPosition < 0) caretPosition = 0;
		const unsigned int tsz = text.text.size();
		if (caretPosition > tsz) caretPosition = tsz;
		
		updateScrolling();
		}
void Vgui_TextEdit::updateScrolling ()
                                {
		if (!isActive) {
			if (!VGUI_FUZZY_ZERO(xScroll)) {
				xScroll = 0;
				markDirty();
				return;
				}
			}
		
		VGUI_COORD tx_caret = 0;
		VGUI_COORD ty_caret = 0;
		Vgui_ContextI::aContext->getTextSize(text.text.substr(0, caretPosition), tx_caret, ty_caret);
		
		VGUI_COORD ipeT, ipeB, ipeL, ipeR;
		getStylePadding(ipeT, ipeB, ipeL, ipeR);
		
		VGUI_COORD internalWidth = drawWidth - ipeL - ipeR;
		if (xScroll > tx_caret) xScroll = tx_caret; // to the left
		if (xScroll < tx_caret - internalWidth) xScroll = tx_caret - internalWidth; // to the right
		}
void Vgui_TextEdit::pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask)
                                                                                      {
		hoverBehaviour_pollMouseState(mouseX, mouseY, buttonMask);
		}
bool Vgui_TextEdit::processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                      {
		return textAreaBehaviour_processMouseEvent(mouseX, mouseY, buttonMask, isDown, false);
		}
bool Vgui_TextEdit::processTextInputEvent (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut)
                                                                                                                       {
		if (isActive) {
			markDirty();
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_INSERT) {
				VGUI_STRING insertStr = string;
				// Strip out any forbidden chars
				vecgui::replaceStringInPlace(insertStr, "\n", "");
				text.insert(caretPosition, insertStr);
				caretPosition += string.length();
				updateScrolling();
				return true;
				}
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_BACKSPACE) {
				unsigned int pos, size;
				sttfont_lookupHint hint; hint.writeOut = true;
				text.text.utf8_charsizeAt(caretPosition-1, pos, size, &hint);
				if (size) {
					text.text.remove(pos, size, &hint);
					text.requestDraw();
					}
				if (caretPosition) caretPosition-=size;
				updateScrolling();
				return true;
				}
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_DELETE) {
				if (caretPosition < text.text.size()) {
					unsigned int pos, size;
					sttfont_lookupHint hint; hint.writeOut = true;
					text.text.utf8_charsizeAt(caretPosition, pos, size);
					text.text.remove(caretPosition, size);
					text.requestDraw();
					}
				updateScrolling();
				return true;
				}
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_CURSOR_LEFT) {
				if (caretPosition > 0) {
					unsigned int pos, size;
					text.text.utf8_charsizeAt(caretPosition-1, pos, size);
					caretPosition = pos;
					}
				else
					caretPosition = 0;
				updateScrolling();
				return true;
				}
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_CURSOR_RIGHT) {
				if (caretPosition < text.text.size()) {
					unsigned int pos, size;
					text.text.utf8_charsizeAt(caretPosition, pos, size);
					caretPosition = pos + size;
					}
				updateScrolling();
				return true;
				}
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_COPY) {
				textOut = text.text.getString();
				return true;
				}
			}
		return false;
		}
#undef LZZ_INLINE
#endif //VECGUI_IMPL_DOUBLE_GUARD_vgui_elements
#endif //VECGUI_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
// vgui_multilinetext.hh
//

#ifndef LZZ_vgui_multilinetext_hh
#define LZZ_vgui_multilinetext_hh
#define LZZ_INLINE inline
class Vgui_MultilineText : public Vgui_Widget
{
public:
  struct textChunk
  {
    VGUI_VECTOR <sttfont_formatted_text> rawRows;
    VGUI_VECTOR <Vgui_TextSubWidget*> mLines;
    VGUI_VECTOR <vecgui::uintQuad> linesToRows;
    VGUI_COORD genWidth;
    VGUI_COORD genHeight;
    VGUI_COORD ySize;
    VGUI_COORD yPos;
    sttfont_formatted_text combinedRows;
    static unsigned int const N_ROWS_PER_CHUNK = 4;
    textChunk ();
    virtual ~ textChunk ();
    void reassemble ();
    void clearLines ();
    void clearLineCache ();
    void breakRow (unsigned int const rowIndex, sttfont_formatted_text const & row, VGUI_COORD const maxWidth);
    void regenerate (VGUI_COORD const maxWidth);
    void dumpLinesToStdOut ();
    unsigned int getSeekPosition (unsigned int const targetLine, unsigned int const targetPos) const;
    void getLineAndPosFromSeekPosition (unsigned int const seekPos, unsigned int & lineOut, unsigned int & posOut) const;
    void insertText (unsigned int & lineIndex, unsigned int & linePos, sttfont_formatted_text_MS text, VGUI_COORD const regenWidth);
    void backspace (unsigned int & chunkIndex, unsigned int & lineIndex, unsigned int & linePos, textChunk * tcBefore, VGUI_COORD const regenWidth);
    void deleteForward (unsigned int & chunkIndex, unsigned int & lineIndex, unsigned int & linePos, textChunk * tcAfter, VGUI_COORD const regenWidth);
    void addLine (sttfont_formatted_text const & row, VGUI_COORD const maxWidth, Vgui_MultilineText * ctr);
    void reassembleAndRegenerate (VGUI_COORD const maxWidth);
    bool needsRegeneration (VGUI_COORD const maxWidth);
    void pollToRegenerate (VGUI_COORD const maxWidth);
  };
  VGUI_VECTOR <textChunk*> mTextChunks;
private:
  unsigned int iChunkStartHint;
  unsigned int iChunkEndHint;
  VGUI_COORD yScrollLast;
  unsigned int caretChunkIndex;
  int caretRow;
  int caretRowPosition;
public:
  Vgui_MultilineText ();
  virtual Vgui_Widget * clone () const;
  virtual ~ Vgui_MultilineText ();
  void clearCache ();
  void getStylePadding (VGUI_COORD & _innerPaddingT, VGUI_COORD & _innerPaddingB, VGUI_COORD & _innerPaddingL, VGUI_COORD & _innerPaddingR) const;
  textChunk * getOrGenActiveChunk ();
  void addLine (sttfont_formatted_text const & str);
  void doAutoscroll (VGUI_COORD const extraPadding);
  void chunkify (VGUI_COORD const chunkWidth);
  VGUI_COORD const getRowWidth ();
  VGUI_COORD const getRowWidth (VGUI_COORD const ipl, VGUI_COORD const ipr);
  void generateLinesFromText ();
  void setCaretPosBasedOnPos (VGUI_COORD mouseX, VGUI_COORD mouseY);
  void pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask);
  bool processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown);
  textChunk * fetchChunkBeingEditied ();
protected:
  void moveCarretWorker (bool MOVE_UP, bool MOVE_DOWN, bool MOVE_LEFT, bool MOVE_RIGHT, Vgui_TextSubWidget * & activeLine, textChunk * & TC, VGUI_COORD const activeLineY, VGUI_COORD const targetLineYAtBottom, VGUI_COORD const rowSz);
  void realignTextChunks (unsigned int chunkStart);
public:
  bool processTextInputEvent (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut);
protected:
  unsigned int findFirstChunkInRange_findMidTextChunk ();
public:
  unsigned int findFirstChunkInRange ();
  void draw (bool const forceDraw);
};
#undef LZZ_INLINE
#endif

////////////////////////////////////////////////////////////////////////

#ifdef VECGUI_IMPL
#ifndef VECGUI_IMPL_DOUBLE_GUARD_vgui_multilinetext
#define VECGUI_IMPL_DOUBLE_GUARD_vgui_multilinetext
// vgui_multilinetext.cpp
//

#define LZZ_INLINE inline
unsigned int const Vgui_MultilineText::textChunk::N_ROWS_PER_CHUNK;
Vgui_MultilineText::textChunk::textChunk ()
  : genWidth (0), genHeight (0), ySize (0), yPos (0)
                                                                           {}
Vgui_MultilineText::textChunk::~ textChunk ()
                                      {
			clearLines();
			}
void Vgui_MultilineText::textChunk::reassemble ()
                                  {
			//bool first = true;
			combinedRows.clear();
			bool first = true;			
			for (const sttfont_formatted_text & sft : rawRows) {
				if (first)
					first = false;
				else
					combinedRows << "\n";
				combinedRows.append(sft);
				}
			combinedRows.consolidateSegments();
			}
void Vgui_MultilineText::textChunk::clearLines ()
                                  {
			for (unsigned int i = 0; i < mLines.size(); ++i)
				VGUI_DEL(mLines[i]);
			mLines.clear();
			linesToRows.clear();
			}
void Vgui_MultilineText::textChunk::clearLineCache ()
                                      {
			//std::cout << "Cleared " << mLines.size() << " lines of prerendered text. " << yPos  << std::endl;
			for (unsigned int i = 0; i < mLines.size(); ++i)
				mLines[i]->clearCache(); // Remove offscreen lines of text from memory
			}
void Vgui_MultilineText::textChunk::breakRow (unsigned int const rowIndex, sttfont_formatted_text const & row, VGUI_COORD const maxWidth)
                                                                                                                          {
			// Takes a row and generates lines from it, appending to end of lines array
			VGUI_VECTOR<sttfont_formatted_text> out;
			unsigned int linesToRowsStart = linesToRows.size();
			Vgui_ContextI::aContext->breakString(row, out, VGUI_MAX(10, maxWidth), true, &linesToRows);
			
			
			for (unsigned int i = 0; i < out.size(); ++i) {
				linesToRows[i+linesToRowsStart].first = rowIndex;
				
				Vgui_TextSubWidget * tsw = VGUI_NEW(Vgui_TextSubWidget);
				if (i == 0) tsw->startsWithNewLine = true;
				tsw->assign(std::move(out[i]));
				mLines.push_back(tsw);
				}
			}
void Vgui_MultilineText::textChunk::regenerate (VGUI_COORD const maxWidth)
                                                           {
			//std::cout << "REGENERATING!! " << maxWidth << " " << rawRows.size()  << std::endl;
			clearLines();
			mLines.reserve(rawRows.size());
			for (unsigned int i = 0; i < rawRows.size(); ++i)  {
				const sttfont_formatted_text & sft = rawRows[i];
				breakRow(i, sft, maxWidth);
				}
				
				
			genWidth = maxWidth;
			ySize = (mLines.size()) * Vgui_ContextI::aContext->getTextLineHeight();
			}
void Vgui_MultilineText::textChunk::dumpLinesToStdOut ()
                                          {
			std::cout << std::endl  << "TextChunk: " << this << std::endl;
			for (unsigned int i = 0; i < mLines.size(); ++i) {
				const vecgui::uintQuad & ltr = linesToRows[i];
				std::cout << "\tmLine: ("<<mLines[i]->text.size()<<") [" << mLines[i]->text.getStringTruncated(180) << "]" << std::endl;
				std::cout << "\t\tRawRow: " << ltr.first << " [" << rawRows[ltr.first].getStringTruncated(180) <<"]"<< std::endl;
				std::cout << "\t\tsub: (" << ltr.second << ", " << ltr.third << ", " << ltr.forth << ") [" << rawRows[ltr.first].extract(ltr.second, ltr.third+ltr.forth).getStringTruncated(180) << "] "<< std::endl;
				}
			}
unsigned int Vgui_MultilineText::textChunk::getSeekPosition (unsigned int const targetLine, unsigned int const targetPos) const
                                                                                                                {
			unsigned int workingPos = 0;
			for (unsigned int i = 0; i < linesToRows.size(); ++i) {
				if (i == targetLine) {
					//std::cout << "getSeekPosition " << targetLine << ", "<< targetPos << " --> " << (workingPos + linesToRows[i].forth + targetPos) << " (" << workingPos << ", " << linesToRows[i].forth << ", " << targetPos << ")"<< std::endl;
					return workingPos + linesToRows[i].forth + targetPos;
					}
				int rowJump = i < linesToRows.size()-1 ? linesToRows[i+1].first - linesToRows[i].first : 0;
				if (i == linesToRows.size()-1) rowJump = 1;
				
				workingPos += linesToRows[i].third + linesToRows[i].forth + rowJump;
				}
			return -1;
			}
void Vgui_MultilineText::textChunk::getLineAndPosFromSeekPosition (unsigned int const seekPos, unsigned int & lineOut, unsigned int & posOut) const
                                                                                                                                    {
			lineOut = -1;
			posOut = -1;
			unsigned int workingPos = 0;
			for (unsigned int i = 0; i < linesToRows.size(); ++i) {
				int rowJump = i < linesToRows.size()-1 ? linesToRows[i+1].first - linesToRows[i].first : 0;
				if (i == linesToRows.size()-1) rowJump = 1;
				
				const unsigned int segLen = linesToRows[i].third + linesToRows[i].forth + rowJump;
				//std::cout << "CHECKING " << seekPos << ", line/row: " << i << ", " << linesToRows[i].first << ", workingPos: " << workingPos << ", pos+segLen: " << (workingPos + segLen) << ", segLen: " << segLen<< ", ltr.3: " << linesToRows[i].third << ", rowJump: "<< rowJump << std::endl;
				if (seekPos >= workingPos && seekPos < workingPos + segLen) {
					lineOut = i;
					posOut = seekPos - workingPos;
					return;
					}
				workingPos += segLen;
				}
			}
void Vgui_MultilineText::textChunk::insertText (unsigned int & lineIndex, unsigned int & linePos, sttfont_formatted_text_MS text, VGUI_COORD const regenWidth)
                                                                                                                                               {
			if (lineIndex >= linesToRows.size()) return;
			const vecgui::uintQuad & ltr = linesToRows[lineIndex];
			const unsigned int rowIndex = ltr.first;
			const unsigned int localPos = ltr.second + linePos;
			if (rowIndex >= rawRows.size()) return;
			// Get the insert location on the row
			
			//std::cout << "Inserting ["  << text.getString() << "] into row [" << rawRows[rowIndex].getStringTruncated(64) << "], line: ("<< ltr.second<< ", " << ltr.third<<")[" << rawRows[rowIndex].extract(ltr.second, ltr.third).getStringTruncated(64) << "] at position " << localPos << std::endl;

			
			unsigned int seekStart = getSeekPosition(lineIndex, linePos) + text.size();
			rawRows[rowIndex].insert(localPos, std::move(text));
			
			// Retokenise on newlines
			VGUI_VECTOR<sttfont_formatted_text> tok; 
			rawRows[rowIndex].tokenise(tok, '\n', false);
			if (tok.size() > 1) {
				//endOfRowDetection = 1 + tok.size();
				rawRows[rowIndex] = tok[0];
				rawRows.insert(rawRows.begin() + rowIndex + 1, std::make_move_iterator(tok.begin()+1), std::make_move_iterator(tok.end()));
				}
				
			// Rebreak and find new line index & position
			reassembleAndRegenerate(regenWidth);
			getLineAndPosFromSeekPosition(seekStart, lineIndex, linePos);
			//linePos+=endOfRowDetection;
			}
void Vgui_MultilineText::textChunk::backspace (unsigned int & chunkIndex, unsigned int & lineIndex, unsigned int & linePos, textChunk * tcBefore, VGUI_COORD const regenWidth)
                                                                                                                                                               {
			// Removes 1 character back
			if (lineIndex >= linesToRows.size()) return;
			const vecgui::uintQuad & ltr = linesToRows[lineIndex];
			const unsigned int rowIndex = ltr.first;
			const unsigned int localPos = ltr.second + linePos;
			if (rowIndex >= rawRows.size()) return;
			
			int deleted = 1;
			
			if (localPos == 0 && rowIndex == 0) {
				// Removing newline at begining of chunk
				// Merge first line with tcBefore's last line
				if (!tcBefore) return;
				if (!tcBefore->rawRows.size()) return;
				if (tcBefore->mLines.size()) tcBefore->regenerate(regenWidth);
									
				tcBefore->rawRows[tcBefore->rawRows.size()-1].append(std::move(rawRows[0]));
				rawRows.erase(rawRows.begin()+0);
				
				reassembleAndRegenerate(regenWidth);
				tcBefore->reassembleAndRegenerate(regenWidth);
				
				chunkIndex--;
				lineIndex = tcBefore->mLines.size()-1;
				linePos = tcBefore->mLines[lineIndex]->text.size();				
				return;
				}
			else if (localPos) {
				// Remove 1 character in middle of row
				unsigned int posOut = 0;
				unsigned int charSz = 0;
				rawRows[rowIndex].utf8_charsizeAt(localPos-1, posOut, charSz);
				rawRows[rowIndex].remove(posOut, charSz);
				deleted = charSz;
				}
			else {
				// Removing newline between rows. Join rows
				rawRows[rowIndex-1].append(std::move(rawRows[rowIndex]));
				rawRows.erase(rawRows.begin()+rowIndex);
				}
			const unsigned int seekStart = getSeekPosition(lineIndex, linePos);
			reassembleAndRegenerate(regenWidth);
			getLineAndPosFromSeekPosition(seekStart - deleted, lineIndex, linePos);
			}
void Vgui_MultilineText::textChunk::deleteForward (unsigned int & chunkIndex, unsigned int & lineIndex, unsigned int & linePos, textChunk * tcAfter, VGUI_COORD const regenWidth)
                                                                                                                                                                  {
			// Removes 1 character forward
			if (lineIndex >= linesToRows.size()) return;
			const vecgui::uintQuad & ltr = linesToRows[lineIndex];
			const unsigned int rowIndex = ltr.first;
			const unsigned int localPos = ltr.second + linePos;
			if (rowIndex >= rawRows.size()) return;
						
			const unsigned int seekStart = getSeekPosition(lineIndex, linePos);
			if (localPos == rawRows[rowIndex].size()) {
				// Removing newline at end of row
				if (rowIndex == rawRows.size()-1) {
					// Merge first line with tcAfter's first line
					if (!tcAfter) return;
					if (!tcAfter->rawRows.size()) return;
					if (tcAfter->mLines.size()) tcAfter->regenerate(regenWidth);
					
					rawRows[rowIndex].append(std::move(tcAfter->rawRows[0]));
					tcAfter->rawRows.erase(tcAfter->rawRows.begin()+0);
					
					tcAfter->reassembleAndRegenerate(regenWidth);
					}
				else {
					// Removing newline between rows. Join rows
					rawRows[rowIndex].append(std::move(rawRows[rowIndex+1]));
					rawRows.erase(rawRows.begin()+rowIndex+1);
					}
				}
			else {
				// Remove 1 character in middle of row
				unsigned int posOut = 0;
				unsigned int charSz = 0;
				rawRows[rowIndex].utf8_charsizeAt(localPos, posOut, charSz);
				rawRows[rowIndex].remove(posOut, charSz);
				}
				
			reassembleAndRegenerate(regenWidth);
			getLineAndPosFromSeekPosition(seekStart, lineIndex, linePos);
			}
void Vgui_MultilineText::textChunk::addLine (sttfont_formatted_text const & row, VGUI_COORD const maxWidth, Vgui_MultilineText * ctr)
                                                                                                                      {
			// Adds a singualr line
			bool isGenerated = mLines.size() && rawRows.size();
			rawRows.push_back(row);
			if (isGenerated) {
				breakRow(rawRows.size()-1, rawRows[rawRows.size()-1], maxWidth);
				ySize = (mLines.size()) * Vgui_ContextI::aContext->getTextLineHeight();
				ctr->markDirty();
				}
			else
				ySize += Vgui_ContextI::aContext->getTextLineHeight();
			}
void Vgui_MultilineText::textChunk::reassembleAndRegenerate (VGUI_COORD const maxWidth)
                                                                        {
			// Regenerates this. Sets the 
			bool hasRows = rawRows.size();
			reassemble();
			clearLines();
			rawRows.clear();
			if (hasRows) combinedRows.tokenise(rawRows, '\n', false);
			regenerate(maxWidth);
			}
bool Vgui_MultilineText::textChunk::needsRegeneration (VGUI_COORD const maxWidth)
                                                                  {
			if (!VGUI_FUZZY_ZERO(maxWidth - genWidth)) return true;
			return rawRows.size() && !mLines.size();
			}
void Vgui_MultilineText::textChunk::pollToRegenerate (VGUI_COORD const maxWidth)
                                                                 {
			if (needsRegeneration(maxWidth))
				regenerate(maxWidth);
			}
Vgui_MultilineText::Vgui_MultilineText ()
  : Vgui_Widget ()
                                             {
		text.isDummy = true;
		isAutoscrolling = true;
		isAutoscrollingActive = true;
		iChunkStartHint = 0;
		iChunkEndHint = 0;
		
		caretChunkIndex = 0;
		caretRow = 0;
		caretRowPosition = 0;
		
		setStyle(wrangleDefaultSkin()->MultilineText);
		}
Vgui_Widget * Vgui_MultilineText::clone () const
                                            {
		Vgui_MultilineText * r = VGUI_NEW(Vgui_MultilineText);
		r->mStyleWrap.mStyle.clearPrimatives();
	
		*r = *this;
		
		r->iChunkStartHint = 0;
		r->iChunkEndHint = 0;
		
		r->caretChunkIndex = 0;
		r->caretRow = 0;
		r->caretRowPosition = 0;
		r->mTextChunks.clear();
		return baseCloneWorker(r);
		}
Vgui_MultilineText::~ Vgui_MultilineText ()
                                       {
		clearCache();
		}
void Vgui_MultilineText::clearCache ()
                           {
		/// "Resets" this. Must be called if the text is changed via this->text = foo
		for (textChunk * tc : mTextChunks)
			VGUI_DEL(tc);
		mTextChunks.clear();
		iChunkStartHint = 0;
		iChunkEndHint = 0;
		}
void Vgui_MultilineText::getStylePadding (VGUI_COORD & _innerPaddingT, VGUI_COORD & _innerPaddingB, VGUI_COORD & _innerPaddingL, VGUI_COORD & _innerPaddingR) const
                                                                                                                                                       {
		wrangleStyle()->getInnerPadding( *this, _innerPaddingT, _innerPaddingB, _innerPaddingL, _innerPaddingR);
		}
Vgui_MultilineText::textChunk * Vgui_MultilineText::getOrGenActiveChunk ()
                                          {
		if (!mTextChunks.size()) {
			textChunk * TC = VGUI_NEW(textChunk);
			mTextChunks.push_back(TC);
			}
		
		return mTextChunks[mTextChunks.size()-1];
		}
void Vgui_MultilineText::addLine (sttfont_formatted_text const & str)
                                                          {
		text.append("\n");
		text.append_formatted_text(str);
				
		textChunk * TC = getOrGenActiveChunk();
		// only generate if visible!
		TC->addLine(str, getRowWidth(), this);
		
		if (TC->rawRows.size() > textChunk::N_ROWS_PER_CHUNK) {
			// Create blank chunk
			textChunk * TC_Last = TC;
			TC = VGUI_NEW(textChunk);
			TC->yPos = TC_Last ? TC_Last->yPos + TC_Last->ySize : 0;
			mTextChunks.push_back(TC);
			}
		}
void Vgui_MultilineText::doAutoscroll (VGUI_COORD const extraPadding)
                                                         {
		textChunk * TC = getOrGenActiveChunk();
		yScrollMax = TC->yPos + TC->ySize + extraPadding;
		//yScrollMax = (mLines.size()+1) * Vgui_ContextI::aContext->getTextLineHeight();
		
		if (isAutoscrolling && isAutoscrollingActive) {
			yScroll = yScrollMax - drawHeight;
			if (yScroll < 0) yScroll = 0;
			}
		}
void Vgui_MultilineText::chunkify (VGUI_COORD const chunkWidth)
                                                   {
		// takes @text, tokenises it by newlines and genereates chunks
		for (textChunk * TC : mTextChunks)
			VGUI_DEL(TC);
		mTextChunks.clear();
		
		VGUI_VECTOR<sttfont_formatted_text> mTok;
		text.text.tokenise(mTok, '\n', false);
		
		// For each blob create a chunk
		mTextChunks.reserve(mTok.size() / textChunk::N_ROWS_PER_CHUNK);
		textChunk * TC = VGUI_NEW(textChunk);
		mTextChunks.push_back(TC);
		for (unsigned int i = 0; i < mTok.size(); ++i) {
			// Uncomment to test this - add row numbers to each row
			//sttfont_formatted_text foo(vecgui::itos(mTextChunks.size()) + "," + vecgui::itos(i) + ": ");
			//foo.append(mTok[i]); 
			//mTok[i] = std::move(foo);
			TC->rawRows.push_back(std::move(mTok[i]));
			if (TC->rawRows.size() > textChunk::N_ROWS_PER_CHUNK) {
				TC = VGUI_NEW(textChunk);
				mTextChunks.push_back(TC);
				}
			}
			
		// For each chunk, guesstimate the y-size
		textChunk * TC_Last = NULL;
		for (textChunk * TC : mTextChunks) {
			TC->ySize = TC->rawRows.size()*Vgui_ContextI::aContext->getTextLineHeight();
			TC->yPos = TC_Last ? TC_Last->yPos + TC_Last->ySize : 0;
			TC_Last = TC;
			}
			
		markDirty();
		}
VGUI_COORD const Vgui_MultilineText::getRowWidth ()
                                        {
		VGUI_COORD ipt, ipb, ipl, ipr;
		wrangleStyle()->getInnerPadding(*this, ipt, ipb, ipl, ipr);
		return getRowWidth(ipl, ipr);
		}
VGUI_COORD const Vgui_MultilineText::getRowWidth (VGUI_COORD const ipl, VGUI_COORD const ipr)
                                                                                  {
		const VGUI_COORD chunkWidth = VGUI_MAX(10, drawWidth - ipl - ipr);
		return chunkWidth;
		}
void Vgui_MultilineText::generateLinesFromText ()
                                      {
		// Needs to be called whenever this is resized, or the text is reset
		chunkify(getRowWidth());
		}
void Vgui_MultilineText::setCaretPosBasedOnPos (VGUI_COORD mouseX, VGUI_COORD mouseY)
                                                                         {
		// Do a binary search for the closest location

		VGUI_COORD ipeL, ipeR, ipeT, ipeB;
		getStylePadding( ipeT, ipeB, ipeL, ipeR);
		
		// mouseTextRelY
		unsigned int chunkI = findFirstChunkInRange();
		if (chunkI >= mTextChunks.size()) {
			// Set to end
			caretChunkIndex = mTextChunks.size()-1;
			caretRow = -1;
			return;
			}
			
		textChunk * tc = mTextChunks[chunkI];
		
		//tc->yPos
		int rawLine = (mouseY - drawY - ipeT + yScroll - tc->yPos) / Vgui_ContextI::aContext->getTextLineHeight();
		// Search for the line
		int localLine = rawLine;
		
		while (tc) {
			if (localLine < int(VGUI_MAX(tc->mLines.size(), tc->rawRows.size()))) {
				caretChunkIndex = chunkI;
				caretRow = localLine;
				break;
				}
			else {
				localLine -= tc->mLines.size();
				chunkI++;
				if (chunkI < mTextChunks.size())
					tc = mTextChunks[chunkI];
				else
					tc = NULL;
				}
			}
			
		if (!tc) {
			// Set to end
			caretChunkIndex = mTextChunks.size()-1;
			caretRow = -1;
			return;
			}
		
		VGUI_COORD textX = ipeL + drawX - xScroll;
		if (caretRow >= 0 && caretRow < int(tc->mLines.size())) {
			caretRowPosition = Vgui_ContextI::aContext->getTextCaretPos(tc->mLines[caretRow]->text, mouseX - textX, 0);
			if (mouseX < textX)
				caretRowPosition = 0;
			if (caretRowPosition < 0)
				caretRowPosition = tc->mLines[caretRow]->text.size();
			}
		else {
			caretRowPosition = -1;
			}
		}
void Vgui_MultilineText::pollMouseState (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask)
                                                                                      {
		scrollbar_pollMouseState(mouseX, mouseY, buttonMask);
		}
bool Vgui_MultilineText::processMouseEvent (VGUI_COORD mouseX, VGUI_COORD mouseY, uint8_t buttonMask, bool isDown)
                                                                                                      {
		if (!buttonMask) return false;
		bool consumed = scrollbar_processMouseEvent(mouseX, mouseY, buttonMask, isDown);
		if (consumed) return consumed;
		return textAreaBehaviour_processMouseEvent(mouseX, mouseY, buttonMask, isDown, true);
		}
Vgui_MultilineText::textChunk * Vgui_MultilineText::fetchChunkBeingEditied ()
                                             {
		if (caretChunkIndex >= 0 && caretChunkIndex < mTextChunks.size())
			return mTextChunks[caretChunkIndex];
		return NULL;
		}
void Vgui_MultilineText::moveCarretWorker (bool MOVE_UP, bool MOVE_DOWN, bool MOVE_LEFT, bool MOVE_RIGHT, Vgui_TextSubWidget * & activeLine, textChunk * & TC, VGUI_COORD const activeLineY, VGUI_COORD const targetLineYAtBottom, VGUI_COORD const rowSz)
                                                                                                                                                                                                                                            {
		if (MOVE_UP || MOVE_LEFT) {
			if (caretRowPosition && MOVE_LEFT) {
				unsigned int pos, size;
				sttfont_lookupHint hint; hint.writeOut = true;
				activeLine->text.utf8_charsizeAt(caretRowPosition-1, pos, size, &hint);
				caretRowPosition = pos;
				}
			else {
				// move up 1 line
				if (caretRow > 0) {
					caretRow--;
					if (MOVE_UP)
						caretRowPosition = VGUI_MIN(int(TC->mLines[caretRow]->text.size()), caretRowPosition);
					else
						caretRowPosition = TC->mLines[caretRow]->text.size();
					}
				else if (caretChunkIndex > 0) {
					caretChunkIndex--;
					TC = mTextChunks[caretChunkIndex];
					if (!TC->mLines.size())
						TC->regenerate(getRowWidth());
					
					caretRow = TC->mLines.size()-1;
					if (caretRow >= 0 && caretRow < int(TC->mLines.size()))
						caretRowPosition = TC->mLines[caretRow]->text.size();
					}
				if (activeLineY <= yScroll)
					yScroll -= rowSz;
					
				if (yScroll > yScrollMax-drawHeight) yScroll = yScrollMax-drawHeight;
				if (yScroll < 0) yScroll = 0;
				}
			}
		
		if (MOVE_DOWN || MOVE_RIGHT) {
			if (caretRowPosition < int(activeLine->text.size()) && MOVE_RIGHT) {
				unsigned int pos, size;
				sttfont_lookupHint hint;
				activeLine->text.utf8_charsizeAt(caretRowPosition, pos, size, &hint);
				caretRowPosition = pos + size;
				}
			else {
				// move down 1 line
				bool moved = false;
				if (caretRow >= int(TC->mLines.size())-1) {
					if (caretChunkIndex < mTextChunks.size() -1) {
						caretRow = 0;
						caretChunkIndex++;
						moved = true;
						TC = mTextChunks[caretChunkIndex];
						if (!TC->mLines.size())
							TC->regenerate(getRowWidth());
						}
					}
				else {
					caretRow++;
					moved = true;
					}
				if (MOVE_DOWN && caretRow < int(TC->mLines.size()))
					caretRowPosition = VGUI_MIN(int(TC->mLines[caretRow]->text.size()), caretRowPosition);
				else if (moved)
					caretRowPosition = 0;
					
				if (yScroll >= targetLineYAtBottom)
					yScroll = targetLineYAtBottom + rowSz;

				if (yScroll > yScrollMax-drawHeight) yScroll = yScrollMax-drawHeight;
				if (yScroll < 0) yScroll = 0;
				}
			}
		}
void Vgui_MultilineText::realignTextChunks (unsigned int chunkStart)
                                                        {
		if (chunkStart >= mTextChunks.size()) return;
		
		for (unsigned int i = chunkStart; i < mTextChunks.size(); ++i ) {
			if (!mTextChunks[i]->rawRows.size()) {
				VGUI_DEL(mTextChunks[i]);
				mTextChunks.erase(mTextChunks.begin() + i);
				if (caretChunkIndex >= i) caretChunkIndex--;
				--i;
				continue;
				}
			if (mTextChunks[i]->rawRows.size() > textChunk::N_ROWS_PER_CHUNK*1.5) {
				unsigned int split = textChunk::N_ROWS_PER_CHUNK;
				textChunk * tcNew = VGUI_NEW(textChunk);
				
				tcNew->rawRows = VGUI_VECTOR<sttfont_formatted_text>(std::make_move_iterator(mTextChunks[i]->rawRows.begin() + split),
																	std::make_move_iterator(mTextChunks[i]->rawRows.end()));
																	
																// Mlines is tricky - first linesToRows that	
				unsigned int split2 = -1;
				
				for (unsigned int j = 0; j < mTextChunks[i]->linesToRows.size(); ++j) {
					if (mTextChunks[i]->linesToRows[j].first == split) {
						split2 = j;
						break;
						}
					}
				
				
				tcNew->mLines = VGUI_VECTOR<Vgui_TextSubWidget*>(std::make_move_iterator(mTextChunks[i]->mLines.begin() + split),
																	std::make_move_iterator(mTextChunks[i]->mLines.end()));
				tcNew->linesToRows = VGUI_VECTOR<vecgui::uintQuad>(std::make_move_iterator(mTextChunks[i]->linesToRows.begin() + split),
																	std::make_move_iterator(mTextChunks[i]->linesToRows.end()));
																	
				mTextChunks[i]->rawRows.erase(mTextChunks[i]->rawRows.begin() + split,  mTextChunks[i]->rawRows.end());
				mTextChunks[i]->mLines.erase(mTextChunks[i]->mLines.begin() + split2,  mTextChunks[i]->mLines.end());
				mTextChunks[i]->linesToRows.erase(mTextChunks[i]->linesToRows.begin() + split2,  mTextChunks[i]->linesToRows.end());
				
				tcNew->genWidth = mTextChunks[i]->genWidth;
				tcNew->genHeight = mTextChunks[i]->genHeight;
				
				const VGUI_COORD rowSz = Vgui_ContextI::aContext->getTextLineHeight();
				tcNew->ySize = tcNew->linesToRows.size()*rowSz;
				mTextChunks[i]->ySize = mTextChunks[i]->linesToRows.size()*rowSz;

				for (unsigned int j = 0; j < tcNew->linesToRows.size(); ++j)
					tcNew->linesToRows[j].first -= split2;
					
				mTextChunks.insert(mTextChunks.begin()+i+1, tcNew);
				
				if (caretChunkIndex == i && caretRow >= int(split2)) {
					caretChunkIndex++; caretRow-= split2;
					}
					
				//mTextChunks[i]->dumpLinesToStdOut();
				//tcNew->dumpLinesToStdOut();
				}
			if (i)
				mTextChunks[i]->yPos = mTextChunks[i-1]->yPos + mTextChunks[i-1]->ySize;
			}
		
		}
bool Vgui_MultilineText::processTextInputEvent (VGUI_STRING const & string, Vgui_TextEditEvent const evType, VGUI_STRING & textOut)
                                                                                                                       {
		if (isActive) {
			markDirty();
		
			const VGUI_COORD rowSz = Vgui_ContextI::aContext->getTextLineHeight();
		
			textChunk * TC = NULL;
			if (caretChunkIndex >= 0 && caretChunkIndex < mTextChunks.size())
				TC = mTextChunks[caretChunkIndex];
			Vgui_TextSubWidget * activeLine = NULL;
			if (TC) {
				if (!TC->mLines.size())
					TC->regenerate(getRowWidth());
				if (caretRow >= 0 && caretRow <= int(TC->mLines.size())) {
					activeLine = TC->mLines[caretRow];
					}
				}
				
			if (!(TC && activeLine)) return false; // should NOT return here
			
			VGUI_COORD ipeL, ipeR, ipeT, ipeB;
			getStylePadding( ipeT, ipeB, ipeL, ipeR);
		
			VGUI_COORD activeLineY = TC->yPos + caretRow*rowSz + ipeT;
			VGUI_COORD targetLineYAtBottom = activeLineY - drawHeight + rowSz + ipeB;
			
			int chunkStart = VGUI_MAX(int(caretChunkIndex)-2, 0);
		
		
			// If is offscreen, set scroll to make this active
			if (activeLineY > yScroll + drawHeight) { // TC is below
				yScroll = targetLineYAtBottom;
				isAutoscrollingActive = false;
				}
			else if (activeLineY < yScroll) { // TC is above
				yScroll = activeLineY;
				isAutoscrollingActive = false;
				}
			if (yScroll > yScrollMax-drawHeight) yScroll = yScrollMax-drawHeight;
			if (yScroll < 0) yScroll = 0;
			
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_INSERT) {
				sttfont_formatted_text insertStr(string);
				unsigned int ucaretRow = caretRow;
				unsigned int ucaretRowPosition = caretRowPosition;
				TC->insertText(ucaretRow, ucaretRowPosition, std::move(insertStr), getRowWidth());
				caretRow = ucaretRow;
				caretRowPosition = ucaretRowPosition;
				realignTextChunks(chunkStart);
				return true;
				}
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_BACKSPACE) {
				unsigned int ucaretChunkIndex = caretChunkIndex;
				unsigned int ucaretRow = caretRow;
				unsigned int ucaretRowPosition = caretRowPosition;
				TC->backspace(ucaretChunkIndex, ucaretRow, ucaretRowPosition, ucaretChunkIndex > 0 ? mTextChunks[ucaretChunkIndex-1] : NULL, getRowWidth());
				caretChunkIndex = ucaretChunkIndex;
				caretRow = ucaretRow;
				caretRowPosition = ucaretRowPosition;
				realignTextChunks(chunkStart);
				return true;
				}
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_DELETE) {
				unsigned int ucaretChunkIndex = caretChunkIndex;
				unsigned int ucaretRow = caretRow;
				unsigned int ucaretRowPosition = caretRowPosition;
				TC->deleteForward(ucaretChunkIndex, ucaretRow, ucaretRowPosition, ucaretChunkIndex+1 < mTextChunks.size() ? mTextChunks[ucaretChunkIndex+1] : NULL, getRowWidth());
				caretChunkIndex = ucaretChunkIndex;
				caretRow = ucaretRow;
				caretRowPosition = ucaretRowPosition;
				realignTextChunks(chunkStart);
				return true;
				}
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_CURSOR_LEFT) {
				moveCarretWorker(false, false, true, false, activeLine, TC, activeLineY, targetLineYAtBottom, rowSz);
				return true;
				}
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_CURSOR_RIGHT) {
				moveCarretWorker(false, false, false, true, activeLine, TC, activeLineY, targetLineYAtBottom, rowSz);
				return true;
				} 
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_CURSOR_UP) {
				moveCarretWorker(true, false, false, false, activeLine, TC, activeLineY, targetLineYAtBottom, rowSz);
				return true;
				}
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_CURSOR_DOWN) {
				moveCarretWorker(false, true, false, false, activeLine, TC, activeLineY, targetLineYAtBottom, rowSz);
				return true;
				}
			if (evType == Vgui_TextEditEvent::VGUI_TEXTEDIT_COPY) {
				// rebuild text and copy
				sttfont_formatted_text r;
				bool first = true;
				for (textChunk * TC : mTextChunks) {
					if (first)
						first = false;
					else
						r << "\n";
					TC->reassemble();
					r.append(TC->combinedRows);
					}
				textOut = r.getString();
				return true;
				}
			}
		return false;
		}
unsigned int Vgui_MultilineText::findFirstChunkInRange_findMidTextChunk ()
                                                              {
		// Does a binary search for a textChunk that is nearest to yScroll
		unsigned int max = mTextChunks.size();
		unsigned int min = 0;
		unsigned int mid = (max + min)/2;
		
		while (max > (min+1)) {
			mid = (max + min)/2;
			if (mTextChunks[mid]->yPos <= yScroll) {
				// Jump forward
				min = mid; continue;
				}
			else {
				// Jump forward
				max = mid; continue;
				}
			}
		return mid;
		}
unsigned int Vgui_MultilineText::findFirstChunkInRange ()
                                             {
		// Finds the first chunk that is visible
		// Note: don't set iChunkStartHint as it will mess with which
		// chunks are visible/which ones are not visible
		
		// Find the chunk
		unsigned int startIndex = 0;
		if (yScroll != 0) {
			startIndex = iChunkStartHint;
			}
		if (startIndex > mTextChunks.size())
			startIndex = mTextChunks.size()-1;
		if (startIndex < 0) startIndex = 0;
			
		// Find the start chunk
		unsigned int _iChunkStartHint = -1;
		redo:
		// First hint - check -5/+5 of the current value to prevent a binary search
		unsigned int stopII = VGUI_MIN(startIndex + 5, mTextChunks.size());
		unsigned int startII = VGUI_MAX(int(startIndex) - 5, 0);
		for (unsigned int ii = startII; ii < stopII; ++ii) {
			if (mTextChunks[ii]->yPos <= yScroll && mTextChunks[ii]->yPos + mTextChunks[ii]->ySize > yScroll) {
				_iChunkStartHint = ii;
				break;
				}
			}
			
		// If not found, do a binary search and check again
		if (_iChunkStartHint > mTextChunks.size()) {
			startIndex = findFirstChunkInRange_findMidTextChunk();
			_iChunkStartHint = 0;	// Prevent a relookup here - default to rendering from the start
			goto redo;
			}
		return _iChunkStartHint;
		}
void Vgui_MultilineText::draw (bool const forceDraw)
                                         {
			
		//uint64_t START = SDL_GetPerformanceCounter();
		const bool genRq = (!text.text.isEmpty() && !mTextChunks.size());
		if (genRq) {
			generateLinesFromText();
			markDirty();
			}
			
		
		VGUI_COORD ipeL, ipeR, ipeT, ipeB;
		getStylePadding( ipeT, ipeB, ipeL, ipeR);
		const VGUI_COORD rowSz = Vgui_ContextI::aContext->getTextLineHeight();
		
		
		const unsigned int iChunkStartLast = iChunkStartHint;
		const unsigned int iChunkEndLast   = iChunkEndHint;
		
		iChunkStartHint = findFirstChunkInRange();
		
		// Itter forward, find end and regenerate if required
		const VGUI_COORD chunkWidth = getRowWidth(ipeL, ipeR); 
		bool bumpAll = false;
		iChunkEndHint = mTextChunks.size();
		for (unsigned int ii = iChunkStartHint; ii < mTextChunks.size(); ++ii) {
			// poll to regenerate
			if (mTextChunks[ii]->yPos < yScroll + drawHeight) {
				if (mTextChunks[ii]->needsRegeneration(chunkWidth)) {
					bumpAll = true;
					}
				}
			else {
				iChunkEndHint = ii;
				break;
				}
			}
		if (iChunkEndHint <= iChunkStartHint) iChunkEndHint = iChunkStartHint+1;
		
		//uint64_t LAST = SDL_GetPerformanceCounter();
		int nRowsRegenerated = 0;
		
		if (bumpAll) {
			VGUI_COORD yCum = 0;	// By seriously, y tho?
			for (unsigned int ii = iChunkStartHint; ii < iChunkEndHint; ++ii) {
				// IF IS IN WINDOW
				if (mTextChunks[ii]->needsRegeneration(chunkWidth)) {
					mTextChunks[ii]->regenerate(chunkWidth);
					nRowsRegenerated += mTextChunks[ii]->mLines.size();
					}
				
				// Bump the next
				if (ii+1 < mTextChunks.size()) {
					yCum = mTextChunks[ii]->yPos + mTextChunks[ii]->ySize - mTextChunks[ii+1]->yPos;
					mTextChunks[ii+1]->yPos += yCum;
					}
				
				// If we have shrunk and moved a new chunk in, process that too
				if (ii == iChunkEndHint-1 && mTextChunks.size() > iChunkEndHint && yCum < 0) {
					if (mTextChunks[ii]->yPos + mTextChunks[ii]->ySize < yScroll + drawHeight) {
						iChunkEndHint++;
						}
					}
				}
			
			if (!VGUI_FUZZY_ZERO(yCum)) { // Only shift if the distance has changed
				for (unsigned int ii = iChunkEndHint+1; ii < mTextChunks.size(); ++ii)
					mTextChunks[ii]->yPos += yCum;
				}
			}
		
		//uint64_t NOW = SDL_GetPerformanceCounter();
		//		std::cout << "Hints (" << iChunkStartHint << ", " << iChunkEndHint << ") last: (" << iChunkStartLast << ", " << iChunkEndLast << "), chunks: " << mTextChunks.size() << " chunkZero.size: " << mTextChunks[0]->rawRows.size() << "/" << mTextChunks[0]->mLines.size()  << std::endl;
		
		// Clear off-screen chunks
		for (unsigned int i = iChunkStartLast; i < iChunkEndLast; ++i) {
			if (i >= iChunkStartHint && i < iChunkEndHint) continue;
			if (i < mTextChunks.size())
				mTextChunks[i]->clearLineCache();
			}
			
		doAutoscroll(ipeT + ipeB);
		
		const bool doDrawCaret = (isActive && caretChunkIndex >= iChunkStartHint && caretChunkIndex < iChunkEndHint && caretChunkIndex >= 0 && caretChunkIndex < mTextChunks.size() );
		
		if (bumpAll || yScrollLast != yScroll || isActive)
			markDirty();
		
		yScrollLast = yScroll;
		
		if (doDraw(forceDraw)) {
			// Draw box
			wrangleStyle()->draw(*this);
				
			Vgui_ContextI::aContext->pushScissor(drawX + ipeL, drawY + ipeT, drawX + drawWidth - ipeR, drawY + drawHeight - ipeB);
			
			if (doDrawCaret) {
				Vgui_Style * SI = wrangleStyle();
				// fetch active line
				textChunk * TC = mTextChunks[caretChunkIndex];
				if (TC) {
					if (caretRow >= 0 && caretRow < int(TC->mLines.size()))
						SI->drawBlinkingCaretAt(TC->mLines[caretRow]->text, caretRowPosition, drawX + ipeL, drawY + ipeT + rowSz*caretRow + TC->yPos - yScroll, 0);
					}
				}
			
			// DRAW
			for (unsigned int i = iChunkStartHint; i < iChunkEndHint; ++i) {
				// Draw lines
				textChunk * TC = mTextChunks[i];
				for (unsigned int j = 0; j < TC->mLines.size(); ++j) {
					const VGUI_COORD localPos = TC->yPos + j*rowSz;
					//std::cout << "Drawing (" << i << ", " << j << "), y: "  << (localPos) << ", yScroll: " << yScroll << " checks:" <<  (localPos < yScroll - rowSz) << " " << (localPos > yScroll + drawHeight)  << std::endl;
					
					if (localPos < yScroll - rowSz) continue;
					if (localPos > yScroll + drawHeight) continue;
					
					TC->mLines[j]->prerender();
					TC->mLines[j]->draw(ipeL + drawX - xScroll, ipeT + drawY + localPos - yScroll);
					}
				}
			
			Vgui_ContextI::aContext->popScissor();
			}
		
		//uint64_t NOW2 = SDL_GetPerformanceCounter();
		//const double deltaTime = (double)((NOW - LAST)*1000 / (double)SDL_GetPerformanceFrequency() );
		//const double deltaTime2 = (double)((NOW2 - START)*1000 / (double)SDL_GetPerformanceFrequency() );
		//if (bumpAll || deltaTime2 > 100) std::cout << "Regenerated - " << nRowsRegenerated << " rows of text - Frametime: " << deltaTime << "ms \t avg: " << (deltaTime/nRowsRegenerated) << "ms, total draw() time: " << deltaTime2 << "ms"<< std::endl;
		

		}
#undef LZZ_INLINE
#endif //VECGUI_IMPL_DOUBLE_GUARD_vgui_multilinetext
#endif //VECGUI_IMPL_IMPL
// This file is autogenerated. See look at the .lzz files in the src/ directory for a more human-friendly version
// vgui_stringfunctions.hh
//

#ifndef LZZ_vgui_stringfunctions_hh
#define LZZ_vgui_stringfunctions_hh
#define LZZ_INLINE inline
namespace vecgui
{
  void tokeniseString (VGUI_STRING const & stringIn, VGUI_VECTOR <VGUI_STRING> & arrOut, char const delimiter, bool checkQuoteMarks = true, char escapeChar = '\\');
}
namespace vecgui
{
  VGUI_STRING itos (int val);
}
namespace vecgui
{
  void replaceStringInPlace (VGUI_STRING & subject, VGUI_STRING const & search, VGUI_STRING const & replace);
}
namespace vecgui
{
  void breakString_worker (sttfont_font_cache * fc, sttfont_formatted_text const & stringIn, VGUI_VECTOR <sttfont_formatted_text> & arrOut, VGUI_COORD const xs, bool const tokeniseNewLines, VGUI_VECTOR <uintQuad> * breakPoints);
}
namespace vecgui
{
  void breakString (VGUI_STRING const & stringIn, VGUI_VECTOR <VGUI_STRING> & arrOut, VGUI_COORD const xs, bool const tokeniseNewLines = true, char const escapeChar = '\\', char const tagChar = '%');
}
#undef LZZ_INLINE
#endif

////////////////////////////////////////////////////////////////////////

#ifdef VECGUI_IMPL
#ifndef VECGUI_IMPL_DOUBLE_GUARD_vgui_stringfunctions
#define VECGUI_IMPL_DOUBLE_GUARD_vgui_stringfunctions
// vgui_stringfunctions.cpp
//

#define LZZ_INLINE inline
namespace vecgui
{
  void tokeniseString (VGUI_STRING const & stringIn, VGUI_VECTOR <VGUI_STRING> & arrOut, char const delimiter, bool checkQuoteMarks, char escapeChar)
                                                                                                                                                                 {
	/**
	 *  Breaks a string s into an array of strings,
	 * tokenised by "delimter" (unless inbetween two """ marks).
	 *  An escape character negates the delimiter
	 */
	size_t n = 1;
	bool open = false;
	const VGUI_STRING & s = stringIn;
	// go though, count the delimiter
	for (size_t i = 0; i < s.length(); ++i) {
		if (s[i] == escapeChar) {
			// Skip the next character
			++i;
			continue;
			}
		if (s[i] == delimiter && !open)
			n++;
		if (s[i] == '"' && checkQuoteMarks) {
			open = !open;
			}
		}
	
	// Add the words
	size_t j = arrOut.size();
	arrOut.resize(j + n);
	open = false;
	for (size_t i = 0; i < s.length(); i++) {
		if (s[i] == escapeChar) {
			// Add the next charcter in regardless
			++i;
			if (i < s.length())
				arrOut[j] += s[i];
			continue;
			}
		if (s[i] != delimiter || open) {
			if (s[i] != '"' || !checkQuoteMarks) {
				arrOut[j] += s[i];
				}
			else {
				open = !open;
				}
			}
		else {
			j++;
			}
		}
	}
}
namespace vecgui
{
  VGUI_STRING itos (int val)
                          {
	// converts int to string. Don't use this. Only use for debugging
	const int size = 12;
	char buf[size+1];
	buf[size] = 0;
	int index = size;
	bool neg = false;
	if (val < 0) {    // Obviously don't need this if val is always positive.
		neg = true;
		val = -val;
		}

	do {
		buf[--index] = (val % 10) + '0';
		val /= 10;
		} while(val);
	if (neg)
		buf[--index] = '-';
	return VGUI_STRING(&buf[index]);
	}
}
namespace vecgui
{
  void replaceStringInPlace (VGUI_STRING & subject, VGUI_STRING const & search, VGUI_STRING const & replace)
                                                                                                          {
	if (search == "") return;
    size_t pos = 0;
    while ((pos = subject.find(search, pos)) < subject.length()) {
		subject.replace(pos, search.length(), replace);
		pos += replace.length();
		}
	}
}
namespace vecgui
{
  void breakString_worker (sttfont_font_cache * fc, sttfont_formatted_text const & stringIn, VGUI_VECTOR <sttfont_formatted_text> & arrOut, VGUI_COORD const xs, bool const tokeniseNewLines, VGUI_VECTOR <uintQuad> * breakPoints)
                                                                          {
	if (breakPoints) {
		VGUI_VECTOR<sttfont_uintQuad> tempBreak;
		fc->breakString(stringIn, arrOut, xs, tokeniseNewLines, &tempBreak);
		uint32_t sz0 = breakPoints->size();
		breakPoints->resize(sz0 + tempBreak.size());
		for (uint32_t i = 0; i < tempBreak.size(); ++i) {
			(*breakPoints)[i+sz0] = uintQuad(tempBreak[i].first, tempBreak[i].second, tempBreak[i].third, tempBreak[i].fourth);
			}
		}
	else
		fc->breakString(stringIn, arrOut, xs, tokeniseNewLines, NULL);
	}
}
namespace vecgui
{
  void breakString (VGUI_STRING const & stringIn, VGUI_VECTOR <VGUI_STRING> & arrOut, VGUI_COORD const xs, bool const tokeniseNewLines, char const escapeChar, char const tagChar)
                                                                                                    {
		abort(); // Is this even used?
	// Trivial case	
	if (tokeniseNewLines) {
		VGUI_VECTOR<VGUI_STRING> tokenised;
		tokeniseString(stringIn, tokenised, '\n', false, 0);
	//	std::cout << "tokenised.size " << tokenised.size() << std::endl;
	//	exit(1);
		for (size_t i = 0; i < tokenised.size(); ++i) {
			breakString (tokenised[i], arrOut, xs, false, escapeChar, tagChar);
			}
		return;
		}
	
	if (Vgui_ContextI::aContext->getTextWidth(stringIn) < xs) {
		arrOut.push_back(stringIn);
		return;
		}
	
	
	// Break up string based on spaces
	VGUI_STRING slast = "";
	size_t j = 0, k = 0;
	size_t extra = 0;
	
	for (size_t i = 0; i < stringIn.size(); ++i) {
		const bool isLastChar = (i == (stringIn.size()-1));
			
		if (stringIn[i] != ' ' && i != (stringIn.size()-1)) continue;
		extra = (i == (stringIn.size()-1)) ? 1 : 0;
		VGUI_STRING s = stringIn.substr(j, i-j + extra);
		
		int test = 0;
		
		test = Vgui_ContextI::aContext->getTextWidth(s);
		
		// Remove any "\%" strings
		vecgui::replaceStringInPlace (s, VGUI_STRING(1,escapeChar) + tagChar, VGUI_STRING(1,tagChar));
		
		if (test > xs) {
			//cout << "Push Back \"" << slast << "\" / \"" << s << "\""  << itos3(i,j,k) << "  " << getConsoleFontStrLen(s) << "/" << itos(xs) << endl;
			if (k)
				arrOut.push_back(slast);
			else {
				arrOut.push_back(s);
				k = i;
				}
			j = k+1;
			k = 0;
			slast = "";
			}
		else {
			k = i;
			slast = s;
			}
		if (isLastChar && j < stringIn.size()) {
			arrOut.push_back (stringIn.substr(j));
			}
		}
	}
}
#undef LZZ_INLINE
#endif //VECGUI_IMPL_DOUBLE_GUARD_vgui_stringfunctions
#endif //VECGUI_IMPL_IMPL
